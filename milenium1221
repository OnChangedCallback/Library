-- // Variables
local uis = game:GetService("UserInputService")
local players = game:GetService("Players")
local ws = game:GetService("Workspace")
local rs = game:GetService("ReplicatedStorage")
local http_service = game:GetService("HttpService")
local gui_service = game:GetService("GuiService")
local lighting = game:GetService("Lighting")
local run = game:GetService("RunService")
local stats = game:GetService("Stats")
local coregui = game:GetService("CoreGui")
local debris = game:GetService("Debris")
local tween_service = game:GetService("TweenService")
local sound_service = game:GetService("SoundService")

local vec2 = Vector2.new
local vec3 = Vector3.new
local dim2 = UDim2.new
local dim = UDim.new 
local rect = Rect.new
local cfr = CFrame.new
local empty_cfr = cfr()
local point_object_space = empty_cfr.PointToObjectSpace
local angle = CFrame.Angles
local dim_offset = UDim2.fromOffset

local color = Color3.new
local rgb = Color3.fromRGB
local hex = Color3.fromHex
local hsv = Color3.fromHSV
local rgbseq = ColorSequence.new
local rgbkey = ColorSequenceKeypoint.new
local numseq = NumberSequence.new
local numkey = NumberSequenceKeypoint.new

local camera = ws.CurrentCamera
local lp = players.LocalPlayer 
local mouse = lp:GetMouse() 
local gui_offset = gui_service:GetGuiInset().Y

local max = math.max 
local floor = math.floor 
local min = math.min 
local abs = math.abs 
local noise = math.noise
local rad = math.rad 
local random = math.random 
local pow = math.pow 
local sin = math.sin 
local pi = math.pi 
local tan = math.tan 
local atan2 = math.atan2 
local clamp = math.clamp 

local insert = table.insert 
local find = table.find 
local remove = table.remove
local concat = table.concat

-- // AutoBuy Variables
local task_wait = task.wait

-- // Silent Aimbot Variables
local drawing_new = Drawing.new
local hookmetamethod = hookmetamethod
local newcclosure = newcclosure
local getnamecallmethod = getnamecallmethod
local checkcaller = checkcaller
local game = game
local enum = Enum
local instance_new = Instance.new
local udim2_new = UDim2.new
local udim2_offset = UDim2.fromOffset

-- // Library
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/Library/refs/heads/main/v5"))()

-- // FFlags Normalization
do
    local function checkFFlags()
        -- Нормализация флагов при запуске скрипта
        local maxBandwidth = getfflag("PhysicsSenderMaxBandwidthBps")
        if maxBandwidth ~= 13 then
            setfflag("PhysicsSenderMaxBandwidthBps", "13")
            print("ФлагПрименен" .. maxBandwidth)
        end
        
        local senderRate = getfflag("S2PhysicsSenderRate")
        if senderRate ~= 1 then
            setfflag("S2PhysicsSenderRate", "1")
            print("ФлагПрименен" .. senderRate)
        end
    end
    
    -- Вызываем нормализацию при запуске скрипта
    checkFFlags()
end

-- // Utility Functions
do
    local utility = {}
    
    function utility:predict(targetPart, predictionX, predictionY)
        if not targetPart then return nil end
        local velocity = targetPart.Velocity or vec3(0, 0, 0)
        return targetPart.Position + vec3(
            velocity.X * predictionX,
            velocity.Y * predictionY,
            velocity.Z * predictionX
        )
    end
    
    function utility:isPlayerKO(player)
        if not player or not player.Character then return false end
        
        -- Проверяем K.O статус через BodyEffects
        local success, isKO = pcall(function()
            local playerInWorkspace = workspace.Players:FindFirstChild(player.Name)
            if playerInWorkspace and playerInWorkspace:FindFirstChild("BodyEffects") then
                local koEffect = playerInWorkspace.BodyEffects:FindFirstChild("K.O")
                if koEffect and koEffect:FindFirstChild("Value") then
                    return koEffect.Value.Value == true
                end
            end
            return false
        end)
        
        if success then
            return isKO
        end
        
        -- Fallback к проверке здоровья если BodyEffects недоступны
        local humanoid = player.Character:FindFirstChild("Humanoid")
        return humanoid and humanoid.Health <= 0
    end
    
    function utility:isPlayerGrabbed(player)
        if not player or not player.Character then return false end
        -- Проверяем, схвачен ли игрок
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid then
            return humanoid.PlatformStand or false
        end
        return false
    end
    
    function utility:hasForceField(player)
        if not player or not player.Character then return false end
        return player.Character:FindFirstChildOfClass("ForceField") ~= nil
    end
    
    function utility:hasWallBetween(fromPosition, toPosition, targetPlayer)
        if not fromPosition or not toPosition or not targetPlayer then return false end
        
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        raycastParams.FilterDescendantsInstances = {targetPlayer.Character, lp.Character}
        
        local direction = (toPosition - fromPosition)
        
        local raycastResult = workspace:Raycast(fromPosition, direction, raycastParams)
        return raycastResult ~= nil
    end
    
    function utility:getClosestPlayer(fovRadius, targetPart, useFov, checks, predX, predY)
        local closestPlayer, closestDistance = nil, math.huge
        
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= lp and player.Character and player.Character:FindFirstChild(targetPart) then
                -- Проверки цели (только при выборе новой цели)
                local skipPlayer = false
                if checks then
                    if checks.checkKO and utility:isPlayerKO(player) then
                        skipPlayer = true
                    elseif checks.checkGrabbed and utility:isPlayerGrabbed(player) then
                        skipPlayer = true
                    elseif checks.checkForceField and utility:hasForceField(player) then
                        skipPlayer = true
                    elseif checks.checkWall and utility:hasWallBetween(camera.CFrame.Position, player.Character[targetPart].Position, player) then
                        skipPlayer = true
                    end
                end
                
                if not skipPlayer then
                    local part = player.Character[targetPart]
                    local predictedPosition = utility:predict(part, predX or 0.021111111, predY or 0.0102)
                    if predictedPosition then
                        local screenPos, onScreen = camera:WorldToViewportPoint(predictedPosition)
                        if onScreen then
                            local mousePos = uis:GetMouseLocation()
                            local distance = (vec2(screenPos.X, screenPos.Y) - mousePos).Magnitude
                            
                            if useFov then
                                if distance < fovRadius and distance < closestDistance then
                                    closestPlayer = part
                                    closestDistance = distance
                                end
                            else
                                if distance < closestDistance then
                                    closestPlayer = part
                                    closestDistance = distance
                                end
                            end
                        end
                    end
                end
            end
        end
        return closestPlayer
    end
    
    _G.silentUtility = utility
end

-- // AutoBuy Module
do
    local autoBuySettings = {
        autoArmor = {
            enabled = false,
            armorValue = 120,
            key = enum.KeyCode.F1,
            keyMode = "Toggle"
        },
        autoGuns = {
            enabled = false,
            selectedWeapons = {"[Rifle]", "[LMG]"},
            key = enum.KeyCode.F2,
            keyMode = "Toggle"
        },
        autoAmmo = {
            enabled = false,
            key = enum.KeyCode.F3,
            keyMode = "Toggle"
        }
    }
    
    -- Shop objects
    local Shop = ws.Ignored.Shop
    local ARMOR_SHOP = Shop["[High-Medium Armor] - $2513"]
    local ARMOR_PRICE = 2513
    
    -- Weapons data
    local WEAPONS = {
        {Name = "[Rifle]", ShopName = "[Rifle] - $0", Enabled = true},
        {Name = "[LMG]", ShopName = "[LMG] - $0", Enabled = true},
        {Name = "[P90]", ShopName = "[P90] - $0", Enabled = false},
        {Name = "[Flintlock]", ShopName = "[Flintlock] - $0", Enabled = false},
        {Name = "[Revolver]", ShopName = "[Revolver] - $0", Enabled = false},
        {Name = "[Double-Barrel SG]", ShopName = "[Double-Barrel SG] - $0", Enabled = false},
        {Name = "[AK47]", ShopName = "[AK47] - $0", Enabled = false},
        {Name = "[TacticalShotgun]", ShopName = "[TacticalShotgun] - $0", Enabled = false},
        {Name = "[SMG]", ShopName = "[SMG] - $0", Enabled = false},
        {Name = "[AR]", ShopName = "[AR] - $0", Enabled = false},
        {Name = "[Silencer]", ShopName = "[Silencer] - $0", Enabled = false},
        {Name = "[Shotgun]", ShopName = "[Shotgun] - $0", Enabled = false}
    }
    
    -- Ammo mapping
    local AMMO_MAP = {
        ["[Rifle]"] = "5 [Rifle Ammo] - $0",
        ["[LMG]"] = "200 [LMG Ammo] - $0",
        ["[P90]"] = "120 [P90 Ammo] - $0",
        ["[Flintlock]"] = "6 [Flintlock Ammo] - $0",
        ["[Revolver]"] = "12 [Revolver Ammo] - $0",
        ["[Double-Barrel SG]"] = "18 [Double-Barrel SG Ammo] - $0",
        ["[AK47]"] = "90 [AK47 Ammo] - $0",
        ["[TacticalShotgun]"] = "20 [TacticalShotgun Ammo] - $0",
        ["[SMG]"] = "80 [SMG Ammo] - $0",
        ["[AR]"] = "100 [AR Ammo] - $0",
        ["[Silencer]"] = "25 [Silencer Ammo] - $0",
        ["[Shotgun]"] = "20 [Shotgun Ammo] - $0"
    }
    
    -- Utility functions
    local autoBuyUtility = {}
    
    function autoBuyUtility:hasWeapon(weaponName)
        if lp.Backpack:FindFirstChild(weaponName) then
            return true
        end
        
        local character = lp.Character
        if character and character:FindFirstChild(weaponName) then
            return true
        end
        
        return false
    end
    
    function autoBuyUtility:getWeaponShop(weaponData)
        return Shop:FindFirstChild(weaponData.ShopName)
    end
    
    function autoBuyUtility:hasItem(itemName)
        local function check(container)
            for _, item in pairs(container:GetChildren()) do
                if item.Name == itemName then
                    return true
                end
            end
            return false
        end
        return check(lp.Backpack) or check(lp.Character)
    end
    
    function autoBuyUtility:getAmmoShop(ammoName)
        return Shop:FindFirstChild(ammoName)
    end
    
    -- Auto buy functions
    local function AutoArmor()
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") and lp.Character:FindFirstChild("BodyEffects") then
            local Origin = lp.Character.HumanoidRootPart.CFrame
            local Armor = lp.Character.BodyEffects.Armor
            
            if Armor.Value <= autoBuySettings.autoArmor.armorValue then
                repeat
                    task_wait()    
                    lp.Character.HumanoidRootPart.CFrame = ARMOR_SHOP.Head.CFrame
                    fireclickdetector(ARMOR_SHOP.ClickDetector)
                until Armor.Value >= 130 or lp.DataFolder.Currency.Value < ARMOR_PRICE
                lp.Character.HumanoidRootPart.CFrame = Origin
            end
        end
    end
    
    local function AutoAmmo(weaponName)
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            local ammoName = AMMO_MAP[weaponName]
            if not ammoName then return end
            
            local inventoryItem = lp.DataFolder.Inventory:FindFirstChild(weaponName)
            local currentAmmo = inventoryItem and tonumber(inventoryItem.Value) or 0
            
            if currentAmmo > 0 then
                return
            end
            
            for _, tool in pairs(lp.Character:GetChildren()) do
                if tool:IsA("Tool") then
                    tool.Parent = lp.Backpack
                end
            end
            
            local Origin = lp.Character.HumanoidRootPart.CFrame
            local ammoShop = autoBuyUtility:getAmmoShop(ammoName)
            
            if ammoShop and ammoShop:FindFirstChild("Head") and ammoShop:FindFirstChild("ClickDetector") then
                for i = 1, 2 do
                    local startAmmo = lp.DataFolder.Inventory:FindFirstChild(weaponName)
                    local startValue = startAmmo and tonumber(startAmmo.Value) or 0
                    
                    repeat
                        task_wait()
                        lp.Character.HumanoidRootPart.CFrame = ammoShop.Head.CFrame
                        fireclickdetector(ammoShop.ClickDetector)
                        
                        local newAmmo = lp.DataFolder.Inventory:FindFirstChild(weaponName)
                        local newValue = newAmmo and tonumber(newAmmo.Value) or 0
                    until newValue > startValue
                end
                
                lp.Character.HumanoidRootPart.CFrame = Origin
            end
        end
    end
    
    local function AutoWeaponsAndAmmo()
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            for _, weaponData in ipairs(WEAPONS) do
                if weaponData.Enabled then
                
                if not autoBuyUtility:hasWeapon(weaponData.Name) then
                    local s, e = pcall(function()
                        local Origin = lp.Character.HumanoidRootPart.CFrame
                        local weaponShop = autoBuyUtility:getWeaponShop(weaponData)
                        
                        if weaponShop and weaponShop:FindFirstChild("Head") and weaponShop:FindFirstChild("ClickDetector") then
                            repeat
                                task_wait()
                                lp.Character.HumanoidRootPart.CFrame = weaponShop.Head.CFrame
                                fireclickdetector(weaponShop.ClickDetector)
                            until autoBuyUtility:hasWeapon(weaponData.Name)
                            
                            lp.Character.HumanoidRootPart.CFrame = Origin
                        end
                    end)
                    if not s then warn("[AutoBuy] Weapon buy error:", weaponData.Name, e) end
                end
                
                if autoBuyUtility:hasWeapon(weaponData.Name) then
                    local s, e = pcall(AutoAmmo, weaponData.Name)
                    if not s then warn("[AutoBuy] Ammo buy error:", weaponData.Name, e) end
                end
                end
            end
        end
    end
    
    local autoBuyConnection = nil
    
    -- Main loop
    local function StartAutoBuy()
        if autoBuyConnection then
            autoBuyConnection = nil
        end
        
        autoBuyConnection = coroutine.create(function()
            while task_wait() do
                if autoBuySettings.autoArmor.enabled then
                    local s, e = pcall(AutoArmor)
                    if not s then warn("[AutoBuy] Armor error:", e) end
                end
                
                if autoBuySettings.autoGuns.enabled and lp.Character then
                    local s2, e2 = pcall(AutoWeaponsAndAmmo)
                    if not s2 then warn("[AutoBuy] weapons/ammo error:", e2) end
                end
                
                if autoBuySettings.autoAmmo.enabled and lp.Character then
                    -- Auto ammo only for existing weapons
                    for _, weaponData in ipairs(WEAPONS) do
                        if autoBuyUtility:hasWeapon(weaponData.Name) then
                            local s3, e3 = pcall(AutoAmmo, weaponData.Name)
                            if not s3 then warn("[AutoBuy] Ammo buy error:", weaponData.Name, e3) end
                        end
                    end
                end
            end
        end)
        
        coroutine.resume(autoBuyConnection)
    end
    
    local function StopAutoBuy()
        if autoBuyConnection then
            autoBuyConnection = nil
        end
    end
    
    _G.autoBuySettings = autoBuySettings
    _G.autoBuyUtility = autoBuyUtility
    _G.StartAutoBuy = StartAutoBuy
    _G.StopAutoBuy = StopAutoBuy
    _G.WEAPONS = WEAPONS
    
    -- ✅ НЕ ЗАПУСКАЕМ АВТОМАТИЧЕСКИ!
end

-- // AntiStomp Module
do
    local antiStompSettings = {
        enabled = false,
        hpThreshold = 10
    }
    
    local antiStompConnection = nil
    
    local function StartAntiStomp()
        if antiStompConnection then
            antiStompConnection = nil
        end
        
        antiStompConnection = coroutine.create(function()
            while true do
                wait(0.1)
                
                if antiStompSettings.enabled and lp.Character then
                    local humanoid = lp.Character:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health <= antiStompSettings.hpThreshold then
                        -- Вызываем смерть локального игрока
                        humanoid.Health = 0
                    end
                end
            end
        end)
        
        coroutine.resume(antiStompConnection)
    end
    
    local function StopAntiStomp()
        if antiStompConnection then
            antiStompConnection = nil
        end
    end
    
    _G.antiStompSettings = antiStompSettings
    _G.StartAntiStomp = StartAntiStomp
    _G.StopAntiStomp = StopAntiStomp
    
    -- ✅ НЕ ЗАПУСКАЕМ АВТОМАТИЧЕСКИ!
end

-- // VelocityBreaker Module
do
    local velocityBreakerSettings = {
        enabled = false,
        velocityX = 0,
        velocityY = 0,
        velocityZ = 0
    }
    
    local velocityConnection = nil
    
    local function StartVelocityBreaker()
        if velocityConnection then
            velocityConnection:Disconnect()
            velocityConnection = nil
        end
        
        velocityConnection = run.Heartbeat:Connect(function()
            if velocityBreakerSettings.enabled then
                local character = lp.Character
                if character and character:FindFirstChild("HumanoidRootPart") then
                    local hrp = character.HumanoidRootPart
                    local originalVel = hrp.Velocity
                    hrp.Velocity = vec3(
                        velocityBreakerSettings.velocityX,
                        velocityBreakerSettings.velocityY,
                        velocityBreakerSettings.velocityZ
                    )
                    run.RenderStepped:Wait()
                    hrp.Velocity = originalVel
                end
            end
        end)
    end
    
    local function StopVelocityBreaker()
        if velocityConnection then
            velocityConnection:Disconnect()
            velocityConnection = nil
        end
    end
    
    _G.velocityBreakerSettings = velocityBreakerSettings
    _G.StartVelocityBreaker = StartVelocityBreaker
    _G.StopVelocityBreaker = StopVelocityBreaker
    
    -- ✅ НЕ ЗАПУСКАЕМ АВТОМАТИЧЕСКИ!
end

-- // AntiFling Module
do
    local antiFlingSettings = {
        enabled = false
    }
    
    local antiFlingConnection = nil
    
    local function DisableCollisionsForAllPlayers()
        if not antiFlingSettings.enabled then return end
        
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= lp and player.Character then
                for _, part in ipairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") and part.CanCollide then
                        part.CanCollide = false
                    end
                end
            end
        end
    end
    
    local function RestoreCollisionsForAllPlayers()
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= lp and player.Character then
                for _, part in ipairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") and not part.CanCollide then
                        part.CanCollide = true
                    end
                end
            end
        end
    end
    
    local function StartAntiFling()
        if antiFlingConnection then
            antiFlingConnection:Disconnect()
        end
        
        if not antiFlingSettings.enabled then return end
        
        -- Постоянный мониторинг и отключение коллизий
        antiFlingConnection = run.Heartbeat:Connect(function()
            if antiFlingSettings.enabled then
                DisableCollisionsForAllPlayers()
            end
        end)
    end
    
    local function StopAntiFling()
        if antiFlingConnection then
            antiFlingConnection:Disconnect()
            antiFlingConnection = nil
        end
        
        -- Восстанавливаем коллизии для всех игроков
        RestoreCollisionsForAllPlayers()
    end
    
    _G.antiFlingSettings = antiFlingSettings
    _G.StartAntiFling = StartAntiFling
    _G.StopAntiFling = StopAntiFling
end

-- // AntiInertia Module
do
    local antiInertiaSettings = {
        enabled = false,
        noInertia = true,
        speed = {
            ground = 1.0,
            air = 0.8
        }
    }
    
    local antiInertiaConnection = nil
    
    local function ToggleAntiInertia(state)
        antiInertiaSettings.enabled = state
        if antiInertiaConnection then
            antiInertiaConnection:Disconnect()
            antiInertiaConnection = nil
        end
        
        if state then
            antiInertiaConnection = run.Heartbeat:Connect(function()
                if not antiInertiaSettings.enabled then return end
                
                local character = lp.Character
                if not character or not character:FindFirstChild("HumanoidRootPart") then return end
                
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if not humanoid then return end
                
                local rootPart = character.HumanoidRootPart
                local moveDir = humanoid.MoveDirection
                
                if moveDir.Magnitude > 0 then
                    -- Просто убираем инерцию без изменения скорости
                    if antiInertiaSettings.noInertia then
                        local currentVel = rootPart.Velocity
                        rootPart.Velocity = vec3(currentVel.X, currentVel.Y, currentVel.Z)
                    end
                elseif antiInertiaSettings.noInertia then
                    rootPart.Velocity = vec3(0, rootPart.Velocity.Y, 0)
                end
            end)
        end
    end
    
    _G.antiInertiaSettings = antiInertiaSettings
    _G.ToggleAntiInertia = ToggleAntiInertia
end

-- // LagSwitch Module
do
    local lagSwitchSettings = {
        enabled = false,
        desyncDelay = 1.2  -- задержка между десинком (freezePlayer + unfreeze)
    }
    
    local lagSwitchConnection = nil
    local isInitialized = false
    
    local function checkFFlags()
        -- Нормализация флагов при первом запуске
        local maxBandwidth = getfflag("PhysicsSenderMaxBandwidthBps")
        if maxBandwidth ~= 13 then
            setfflag("PhysicsSenderMaxBandwidthBps", "13")
        end
        
        local senderRate = getfflag("S2PhysicsSenderRate")
        if senderRate ~= 1 then
            setfflag("S2PhysicsSenderRate", "1")
        end
        
        isInitialized = true
    end
    
    local function freezePlayer()
        setfflag("PhysicsSenderMaxBandwidthBps", "1")
        setfflag("S2PhysicsSenderRate", "200")
    end
    
    local function unfreezePlayer()
        setfflag("PhysicsSenderMaxBandwidthBps", "13")
        setfflag("S2PhysicsSenderRate", "1")
    end
    
    local function StartLagSwitch()
        if lagSwitchConnection then
            lagSwitchConnection:Disconnect()
            lagSwitchConnection = nil
        end
        
        if not lagSwitchSettings.enabled then return end
        
        -- Инициализация флагов при первом запуске
        if not isInitialized then
            checkFFlags()
        end
        
        lagSwitchConnection = coroutine.create(function()
            while lagSwitchSettings.enabled do
                -- Фриз игрока
                freezePlayer()
                task_wait(lagSwitchSettings.desyncDelay) -- задержка между freeze и unfreeze (слайдер)
                
                -- Анфриз игрока
                unfreezePlayer()
                task_wait(0.2) -- короткая пауза перед следующим циклом
            end
        end)
        
        coroutine.resume(lagSwitchConnection)
    end
    
    local function StopLagSwitch()
        lagSwitchSettings.enabled = false
        
        if lagSwitchConnection then
            lagSwitchConnection = nil
        end
        
        -- Восстанавливаем нормальные флаги при выключении
        if isInitialized then
            unfreezePlayer()
        end
    end
    
    _G.lagSwitchSettings = lagSwitchSettings
    _G.StartLagSwitch = StartLagSwitch
    _G.StopLagSwitch = StopLagSwitch
end

-- // SpeedHack Module
do
    local speedHackSettings = {
        enabled = false,
        speed = 1
    }
    
    local speedHackConnection = nil
    
    local function hasCharacter(player)
        return player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid")
    end
    
    local function StartSpeedHack()
        if speedHackConnection then
            speedHackConnection:Disconnect()
            speedHackConnection = nil
        end
        
        speedHackConnection = run.Heartbeat:Connect(function(deltaTime)
            if speedHackSettings.enabled and hasCharacter(lp) then
                local speed = speedHackSettings.speed
                local rootPart = lp.Character.HumanoidRootPart
                local humanoid = lp.Character.Humanoid
                
                rootPart.CFrame = rootPart.CFrame + humanoid.MoveDirection * speed
            end
        end)
    end
    
    local function StopSpeedHack()
        if speedHackConnection then
            speedHackConnection:Disconnect()
            speedHackConnection = nil
        end
    end
    
    _G.speedHackSettings = speedHackSettings
    _G.StartSpeedHack = StartSpeedHack
    _G.StopSpeedHack = StopSpeedHack
end

-- // FlyHack Module
do
    local flyHackSettings = {
        enabled = false,
        speed = 50
    }
    
    local flyHackConnection = nil
    
    local function hasCharacter(player)
        return player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid")
    end
    
    local function StartFlyHack()
        if flyHackConnection then
            flyHackConnection:Disconnect()
            flyHackConnection = nil
        end
        
        flyHackConnection = run.Heartbeat:Connect(function(deltaTime)
            if flyHackSettings.enabled and hasCharacter(lp) then
                local moveDirection = lp.Character.Humanoid.MoveDirection
                local hrp = lp.Character.HumanoidRootPart
                local flySpeed = flyHackSettings.speed
                
                -- Вертикальное движение (Space - вверх, LeftShift - вниз)
                local add = vec3(0, (uis:IsKeyDown(enum.KeyCode.Space) and flySpeed / 8 or uis:IsKeyDown(enum.KeyCode.LeftShift) and -flySpeed / 8) or 0, 0)
                
                -- Горизонтальное движение
                hrp.CFrame = hrp.CFrame + (moveDirection * deltaTime) * flySpeed * 10
                hrp.CFrame = hrp.CFrame + add
                hrp.Velocity = (hrp.Velocity * vec3(1, 0, 1)) + vec3(0, 1.9, 0)
            end
        end)
    end
    
    local function StopFlyHack()
        if flyHackConnection then
            flyHackConnection:Disconnect()
            flyHackConnection = nil
        end
    end
    
    _G.flyHackSettings = flyHackSettings
    _G.StartFlyHack = StartFlyHack
    _G.StopFlyHack = StopFlyHack
end

-- // NoJumpCooldown Module
do
    local noJumpCooldownSettings = {
        enabled = false
    }
    
    local noJumpCDOldNewIndex = nil
    
    local function StartNoJumpCooldown()
        -- Ensure game is loaded before hook
        if not game:IsLoaded() then 
            game.Loaded:Wait() 
        end
        
        -- Hook __newindex once, gate by enabled state
        if not noJumpCDOldNewIndex then
            noJumpCDOldNewIndex = hookmetamethod(game, "__newindex", function(self, Index, Value)
                if not checkcaller() and self:IsA("Humanoid") and Index == "JumpPower" and noJumpCooldownSettings.enabled then
                    return
                end
                return noJumpCDOldNewIndex(self, Index, Value)
            end)
        end
    end
    
    local function StopNoJumpCooldown()
        -- Просто отключаем функционал через enabled флаг
        -- Хук остается активным, но не блокирует JumpPower
        noJumpCooldownSettings.enabled = false
    end
    
    -- Инициализируем хук сразу при загрузке модуля
    StartNoJumpCooldown()
    
    _G.noJumpCooldownSettings = noJumpCooldownSettings
    _G.StartNoJumpCooldown = StartNoJumpCooldown
    _G.StopNoJumpCooldown = StopNoJumpCooldown
end

-- // HitboxExpander Module
do
    local hitboxExpanderSettings = {
        enabled = false,
        size = 10,
        visible = false
    }
    
    local hitboxExpandedPlayers = {}
    local hitboxConnection = nil
    
    local function IsKO(player)
        -- Простая проверка на KO - можно расширить при необходимости
        return player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health <= 0
    end
    
    local function ExpandHitbox(player, size, visible)
        if not player.Character then return end
        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        if not hitboxExpandedPlayers[player] then
            hitboxExpandedPlayers[player] = {
                OriginalSize = hrp.Size,
                OriginalTransparency = hrp.Transparency,
                OriginalCanCollide = hrp.CanCollide,
                SelectionBox = nil
            }
        end
        
        local data = hitboxExpandedPlayers[player]
        hrp.Size = vec3(size, size, size)
        hrp.CanCollide = false
        
        if visible then
            hrp.Transparency = 0.5 -- partially transparent so visible but not fully blocking
            if not data.SelectionBox then
                local selBox = instance_new("SelectionBox")
                selBox.Adornee = hrp
                selBox.Color3 = rgb(255, 0, 0)
                selBox.LineThickness = 0.05
                selBox.SurfaceTransparency = 0.7
                selBox.Parent = hrp
                data.SelectionBox = selBox
            end
        else
            hrp.Transparency = 1 -- fully invisible
            if data.SelectionBox then
                data.SelectionBox:Destroy()
                data.SelectionBox = nil
            end
        end
    end
    
    local function ResetHitbox(player)
        if not player.Character then return end
        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
        local data = hitboxExpandedPlayers[player]
        if hrp and data then
            hrp.Size = data.OriginalSize
            hrp.Transparency = data.OriginalTransparency
            hrp.CanCollide = data.OriginalCanCollide
            if data.SelectionBox then
                data.SelectionBox:Destroy()
                data.SelectionBox = nil
            end
            hitboxExpandedPlayers[player] = nil
        end
    end
    
    local function UpdateHitboxes()
        local enabled = hitboxExpanderSettings.enabled
        local size = hitboxExpanderSettings.size
        local visible = hitboxExpanderSettings.visible
        
        for _, player in pairs(players:GetPlayers()) do
            if player ~= lp and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                if enabled and not IsKO(player) then
                    ExpandHitbox(player, size, visible)
                else
                    ResetHitbox(player)
                end
            end
        end
    end
    
    local function StartHitboxExpander()
        if hitboxConnection then
            hitboxConnection:Disconnect()
            hitboxConnection = nil
        end
        
        hitboxConnection = run.Heartbeat:Connect(UpdateHitboxes)
    end
    
    local function StopHitboxExpander()
        if hitboxConnection then
            hitboxConnection:Disconnect()
            hitboxConnection = nil
        end
        
        -- Reset all hitboxes when stopping
        for player, _ in pairs(hitboxExpandedPlayers) do
            ResetHitbox(player)
        end
    end
    
    _G.hitboxExpanderSettings = hitboxExpanderSettings
    _G.StartHitboxExpander = StartHitboxExpander
    _G.StopHitboxExpander = StopHitboxExpander
end

-- // NoRecoil Module
do
    local noRecoilSettings = {
        enabled = false
    }
    
    local noRecoilOldNewIndex = nil
    
    local function isFramework(scr) 
        return tostring(scr) == "Framework" 
    end
    
    local function checkArgs(inst, idx) 
        return tostring(inst):lower():find("camera") and tostring(idx) == "CFrame" 
    end
    
    local function StartNoRecoil()
        -- Ensure game is loaded before hook
        if not game:IsLoaded() then 
            game.Loaded:Wait() 
        end
        
        -- Hook __newindex once, gate by enabled state
        if not noRecoilOldNewIndex then
            noRecoilOldNewIndex = hookmetamethod(game, "__newindex", function(self, idx, val)
                if noRecoilSettings.enabled and isFramework(getcallingscript()) and checkArgs(self, idx) then 
                    return 
                end
                return noRecoilOldNewIndex(self, idx, val)
            end)
        end
    end
    
    local function StopNoRecoil()
        -- Просто отключаем функционал через enabled флаг
        -- Хук остается активным, но не блокирует CFrame
        noRecoilSettings.enabled = false
    end
    
    -- Инициализируем хук сразу при загрузке модуля
    StartNoRecoil()
    
    _G.noRecoilSettings = noRecoilSettings
    _G.StartNoRecoil = StartNoRecoil
    _G.StopNoRecoil = StopNoRecoil
end

-- // NoSpread Module
do
    local noSpreadSettings = {
        enabled = false,
        amount = 0  -- 0-100, lower = less spread
    }
    
    local noSpreadOldRandom = nil
    
    local function StartNoSpread()
        -- Hook math.random once
        if not noSpreadOldRandom then
            noSpreadOldRandom = hookfunction(math.random, function(...)
                local args = {...}
                if checkcaller() then
                    return noSpreadOldRandom(...)
                end
                
                if (#args == 0) or 
                   (args[1] == -0.05 and args[2] == 0.05) or 
                   (args[1] == -0.1) or
                   (args[1] == -0.05) then
                    if noSpreadSettings.enabled then
                        local spread = noSpreadSettings.amount
                        return noSpreadOldRandom(...) * (spread / 100)
                    else
                        return noSpreadOldRandom(...)
                    end
                end
                return noSpreadOldRandom(...)
            end)
        end
    end
    
    local function StopNoSpread()
        -- Просто отключаем функционал через enabled флаг
        -- Хук остается активным, но не изменяет math.random
        noSpreadSettings.enabled = false
    end
    
    -- Инициализируем хук сразу при загрузке модуля
    StartNoSpread()
    
    _G.noSpreadSettings = noSpreadSettings
    _G.StartNoSpread = StartNoSpread
    _G.StopNoSpread = StopNoSpread
end

-- // Window
local window = library:window({
    name = "R4ZE", 
    suffix = ".PUB", 
    gameInfo = "Raze.pub v3"
})

-- // Combat Tab
do
    local CameraBotTab, SilentBotTab, OtherTab = window:tab({
        name = "Combat", 
        icon = "rbxassetid://10734975692",  -- lucide-target
        tabs = {"CameraBot", "SilentBot", "Other"}
    })
    
    -- CameraBot Section
    do
        local CameraBotSection = CameraBotTab:column({})
        local section = CameraBotSection:section({name = "CameraBot", default = false})
        
        -- Camera Aimbot Implementation
        do
            -- Camera Aimbot Variables
            local cameraSettings = {
                enabled = false,
                stickyTarget = nil,
                stickyEnabled = false,
                targetPart = "Head",
                aimlockType = "Mouse Movement",
                -- Prediction settings
                predictionEnabled = false,
                customPredictionX = 0.021111111,
                customPredictionY = 0.0102,
                -- Resolver settings
                resolverEnabled = false,
                resolverMode = "Velocity",
                -- Checks settings
                checksEnabled = false,
                checkKO = false,
                checkGrabbed = false,
                checkForceField = false,
                checkWall = false
            }
            
            -- Helper Functions
            local function MouseMover(X, Y)
                mousemoverel(X, Y)    
            end
            
            local function getCameraTarget()
                if cameraSettings.stickyEnabled then
                    if cameraSettings.stickyTarget and cameraSettings.stickyTarget.Parent then
                        return cameraSettings.stickyTarget
                    else
                        -- Захватываем новую цель если sticky включен
                        local checks = cameraSettings.checksEnabled and {
                            checkKO = cameraSettings.checkKO,
                            checkGrabbed = cameraSettings.checkGrabbed,
                            checkForceField = cameraSettings.checkForceField,
                            checkWall = cameraSettings.checkWall
                        } or nil
                        local predX = cameraSettings.predictionEnabled and cameraSettings.customPredictionX or 0
                        local predY = cameraSettings.predictionEnabled and cameraSettings.customPredictionY or 0
                        cameraSettings.stickyTarget = _G.silentUtility:getClosestPlayer(math.huge, cameraSettings.targetPart, false, checks, predX, predY)
                        return cameraSettings.stickyTarget
                    end
                else
                    cameraSettings.stickyTarget = nil
                    return nil
                end
            end
            
            -- Main Camera Aimbot Toggle
            local mainToggle = section:toggle({
                name = "Camera Aimbot", 
                flag = "camera_enabled",
                type = "toggle",
                callback = function(bool)
                    cameraSettings.enabled = bool
                    if not bool then
                        cameraSettings.stickyTarget = nil
                    end
                end,
                seperator = true
            })
            
            -- Sticky Target Keybind  
            section:keybind({
                name = "Sticky Target",
                flag = "camera_sticky_key", 
                key = enum.KeyCode.T,
                mode = "Toggle",
                default = false,
                callback = function(active)
                    cameraSettings.stickyEnabled = active
                end,
                seperator = true
            })
            
            -- Aimlock Type Dropdown
            section:dropdown({
                name = "Aimlock Type",
                flag = "camera_aimlock_type",
                items = {
                    "Mouse Movement",
                    "MoveCenterOfScreen"
                },
                default = "Mouse Movement",
                callback = function(selected)
                    cameraSettings.aimlockType = selected
                end,
                seperator = true
            })
            
            -- Prediction Toggle
            local predictionToggle = section:toggle({
                name = "Prediction", 
                flag = "camera_prediction_enabled",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.predictionEnabled = bool
                end,
                seperator = true
            })
            
            -- Prediction Settings Sub-section
            local predictionSubSection = predictionToggle:settings({})
            
            -- Prediction X Textbox
            predictionSubSection:textbox({
                name = "Prediction X",
                flag = "camera_prediction_x",
                placeholder = "0.021111111",
                callback = function(text)
                    local value = tonumber(text)
                    if value then
                        cameraSettings.customPredictionX = value
                    end
                end,
                seperator = true
            })
            
            -- Prediction Y Textbox
            predictionSubSection:textbox({
                name = "Prediction Y",
                flag = "camera_prediction_y",
                placeholder = "0.0102",
                callback = function(text)
                    local value = tonumber(text)
                    if value then
                        cameraSettings.customPredictionY = value
                    end
                end,
                seperator = true
            })
            
            -- Resolver Toggle
            local resolverToggle = section:toggle({
                name = "Resolver", 
                flag = "camera_resolver_enabled",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.resolverEnabled = bool
                end,
                seperator = true
            })
            
            -- Resolver Settings Sub-section
            local resolverSubSection = resolverToggle:settings({})
            
            -- Resolver Mode Dropdown
            resolverSubSection:dropdown({
                name = "Resolver Mode",
                flag = "camera_resolver_mode",
                items = {
                    "Velocity",
                    "MoveDirection", 
                    "CalculateCFrame"
                },
                default = "Velocity",
                callback = function(selected)
                    cameraSettings.resolverMode = selected
                end,
                seperator = true
            })
            
            -- Hitparts Dropdown
            section:dropdown({
                name = "Hitparts",
                flag = "camera_hitparts",
                items = {
                    "Head",
                    "UpperTorso", 
                    "LowerTorso",
                    "LeftUpperArm",
                    "LeftLowerArm",
                    "LeftHand",
                    "RightUpperArm",
                    "RightLowerArm", 
                    "RightHand",
                    "LeftUpperLeg",
                    "LeftLowerLeg",
                    "LeftFoot",
                    "RightUpperLeg",
                    "RightLowerLeg",
                    "RightFoot"
                },
                default = "Head",
                callback = function(selected)
                    cameraSettings.targetPart = selected
                end,
                seperator = true
            })
            
            -- Checks Toggle
            local checksToggle = section:toggle({
                name = "Checks", 
                flag = "camera_checks_enabled",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checksEnabled = bool
                end,
                seperator = true
            })
            
            -- Checks Settings Sub-section
            local checksSubSection = checksToggle:settings({})
            
            -- KO Check
            checksSubSection:toggle({
                name = "Check K.O",
                flag = "camera_check_ko",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checkKO = bool
                end,
                seperator = true
            })
            
            -- Grabbed Check
            checksSubSection:toggle({
                name = "Check Grabbed",
                flag = "camera_check_grabbed",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checkGrabbed = bool
                end,
                seperator = true
            })
            
            -- ForceField Check
            checksSubSection:toggle({
                name = "Check ForceField",
                flag = "camera_check_forcefield",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checkForceField = bool
                end,
                seperator = true
            })
            
            -- Wall Check
            checksSubSection:toggle({
                name = "Check Wall",
                flag = "camera_check_wall",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checkWall = bool
                end,
                seperator = true
            })
            
            -- Camera Aimbot Loop
            run.RenderStepped:Connect(function()
                if not cameraSettings.enabled then
                    return
                end
                
                local target = getCameraTarget()
                if target then
                    -- Используем prediction если включен
                    local targetPosition = target.Position
                    if cameraSettings.predictionEnabled then
                        local predX = cameraSettings.customPredictionX
                        local predY = cameraSettings.customPredictionY
                        targetPosition = _G.silentUtility:predict(target, predX, predY) or target.Position
                    end
                    
                    local screenPos, onScreen = camera:WorldToViewportPoint(targetPosition)
                    
                    if onScreen then
                        if cameraSettings.aimlockType == "Mouse Movement" then
                            local mousePos = uis:GetMouseLocation()
                            local deltaX = screenPos.X - mousePos.X
                            local deltaY = screenPos.Y - mousePos.Y
                            
                            -- Перемещаем курсор к цели
                            MouseMover(deltaX, deltaY)
                            
                        elseif cameraSettings.aimlockType == "MoveCenterOfScreen" then
                            local screenSize = camera.ViewportSize
                            local centerX = screenSize.X / 2
                            local centerY = screenSize.Y / 2
                            
                            local deltaX = screenPos.X - centerX
                            local deltaY = screenPos.Y - centerY
                            
                            -- Двигаем камеру чтобы цель была в центре экрана
                            local currentCFrame = camera.CFrame
                            local lookDirection = (targetPosition - currentCFrame.Position).Unit
                            camera.CFrame = cfr(currentCFrame.Position, currentCFrame.Position + lookDirection)
                        end
                    end
                end
            end)
            
        end
    end
    
    -- SilentBot Section  
    do
        local SilentBotSection = SilentBotTab:column({})
        local section = SilentBotSection:section({name = "SilentBot", default = false})
        
        -- Silent Aimbot Implementation
        do
            -- Silent Aimbot Variables
            local silentSettings = {
                enabled = false,
                stickyTarget = nil,
                fovRadius = 350,
                targetPart = "Head",
                useFov = true,
                showFov = true,
                fovColor = rgb(0, 169, 255),
                fovTransparency = 0.5,
                predictionX = 0.021111111,
                predictionY = 0.0102,
                stickyKey = enum.KeyCode.C,
                -- Visualise settings
                visualiseEnabled = false,
                highlightEnabled = false,
                highlightFillColor = rgb(0, 169, 255),
                highlightFillTransparency = 0.5,
                highlightOutlineColor = rgb(0, 169, 255),
                highlightOutlineTransparency = 0.5,
                tracerEnabled = false,
                tracerColor = rgb(0, 169, 255),
                tracerTransparency = 0.5,
                -- Checks settings
                checksEnabled = false,
                checkKO = false,
                checkGrabbed = false,
                checkForceField = false,
                checkWall = false,
                -- Prediction settings
                predictionEnabled = false,
                customPredictionX = 0.021111111,
                customPredictionY = 0.0102,
                -- Resolver settings
                resolverEnabled = false,
                resolverMode = "Velocity",
                -- Sticky settings
                stickyEnabled = false
            }
            
            -- ScreenGui FOV Circle
            local screenGui = instance_new("ScreenGui")
            screenGui.Name = "SilentAimbotFOV"
            screenGui.Parent = coregui
            
            local fovFrame = instance_new("Frame")
            fovFrame.Name = "FOVCircle"
            fovFrame.BackgroundTransparency = 1
            fovFrame.BorderSizePixel = 0
            fovFrame.Size = udim2_offset(silentSettings.fovRadius * 2, silentSettings.fovRadius * 2)
            fovFrame.Position = udim2_offset(0, 0)
            fovFrame.AnchorPoint = vec2(0.5, 0.5)
            fovFrame.Visible = false
            fovFrame.Parent = screenGui
            
            local fovCircle = instance_new("UIStroke")
            fovCircle.Thickness = 2
            fovCircle.Color = silentSettings.fovColor
            fovCircle.Transparency = silentSettings.fovTransparency
            fovCircle.Parent = fovFrame
            
            local fovCorner = instance_new("UICorner")
            fovCorner.CornerRadius = dim(0.5, 0)
            fovCorner.Parent = fovFrame
            
            local esp = nil
            local tracerLine = drawing_new("Line")
            tracerLine.Thickness = 2
            tracerLine.Color = silentSettings.tracerColor
            tracerLine.Transparency = silentSettings.tracerTransparency
            tracerLine.Visible = false
            
            -- Helper Functions
            local function highlightPlayer(target)
                if not silentSettings.visualiseEnabled or not silentSettings.highlightEnabled then
                    return
                end
                
                if esp then esp:Destroy() end
                esp = instance_new("Highlight")
                esp.Adornee = target.Parent
                esp.FillColor = silentSettings.highlightFillColor
                esp.OutlineColor = silentSettings.highlightOutlineColor
                esp.FillTransparency = silentSettings.highlightFillTransparency
                esp.OutlineTransparency = silentSettings.highlightOutlineTransparency
                esp.Parent = target.Parent
            end
            
            local function updateTracer(targetPosition)
                if not silentSettings.visualiseEnabled or not silentSettings.tracerEnabled then
                    tracerLine.Visible = false
                    return
                end
                
                if targetPosition then
                    tracerLine.Visible = true
                    tracerLine.From = uis:GetMouseLocation()
                    local screenPos, onScreen = camera:WorldToViewportPoint(targetPosition)
                    if onScreen then
                        tracerLine.To = vec2(screenPos.X, screenPos.Y)
                    else
                        tracerLine.Visible = false
                    end
                else
                    tracerLine.Visible = false
                end
            end
            
            local function destroyVisuals()
                if esp then esp:Destroy() end
                esp = nil
                tracerLine.Visible = false
            end
            
            local function getTarget()
                if silentSettings.stickyEnabled then
                    if silentSettings.stickyTarget and silentSettings.stickyTarget.Parent then
                        return silentSettings.stickyTarget
                    else
                        -- Захватываем новую цель если sticky включен
                        local checks = silentSettings.checksEnabled and {
                            checkKO = silentSettings.checkKO,
                            checkGrabbed = silentSettings.checkGrabbed,
                            checkForceField = silentSettings.checkForceField,
                            checkWall = silentSettings.checkWall
                        } or nil
                        local predX = silentSettings.predictionEnabled and silentSettings.customPredictionX or silentSettings.predictionX
                        local predY = silentSettings.predictionEnabled and silentSettings.customPredictionY or silentSettings.predictionY
                        silentSettings.stickyTarget = _G.silentUtility:getClosestPlayer(silentSettings.fovRadius, silentSettings.targetPart, silentSettings.useFov, checks, predX, predY)
                        return silentSettings.stickyTarget
                    end
                else
                    silentSettings.stickyTarget = nil
                    -- Свободный захват цели
                    local checks = silentSettings.checksEnabled and {
                        checkKO = silentSettings.checkKO,
                        checkGrabbed = silentSettings.checkGrabbed,
                        checkForceField = silentSettings.checkForceField,
                        checkWall = silentSettings.checkWall
                    } or nil
                    local predX = silentSettings.predictionEnabled and silentSettings.customPredictionX or silentSettings.predictionX
                    local predY = silentSettings.predictionEnabled and silentSettings.customPredictionY or silentSettings.predictionY
                    return _G.silentUtility:getClosestPlayer(silentSettings.fovRadius, silentSettings.targetPart, silentSettings.useFov, checks, predX, predY)
                end
            end
            
            -- Main Silent Aimbot Toggle
            local mainToggle = section:toggle({
                name = "Silent Aimbot", 
                flag = "silent_enabled",
                type = "toggle",
                callback = function(bool)
                    silentSettings.enabled = bool
                    if not bool then
                        destroyVisuals()
                        fovFrame.Visible = false
                    end
                end,
                seperator = true
            })
            
            -- Sticky Target Keybind  
            section:keybind({
                name = "Sticky Target",
                flag = "silent_sticky_key", 
                key = enum.KeyCode.C,
                mode = "Toggle",
                default = false,
                callback = function(active)
                    silentSettings.stickyEnabled = active
                end,
                seperator = true
            })
            
            -- FOV Toggle
            local fovToggle = section:toggle({
                name = "FOV", 
                flag = "silent_fov_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.useFov = bool
                end,
                seperator = true
            })
            
            -- FOV Settings Sub-section
            local fovSubSection = fovToggle:settings({})
            
            fovSubSection:slider({
                name = "FOV Size", 
                flag = "silent_fov_size",
                min = 50, 
                max = 500, 
                default = 350, 
                interval = 1,
                callback = function(value)
                    silentSettings.fovRadius = value
                    fovFrame.Size = udim2_offset(value * 2, value * 2)
                end,
                seperator = true
            })
            
            local showFovToggle = fovSubSection:toggle({
                name = "Show FOV", 
                flag = "silent_show_fov",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.showFov = bool
                    if not bool then
                        fovFrame.Visible = false
                    end
                end,
                seperator = true
            })
            
            showFovToggle:colorpicker({
                name = "FOV Color",
                flag = "silent_fov_color",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.fovColor = color
                    silentSettings.fovTransparency = transparency
                    fovCircle.Color = color
                    fovCircle.Transparency = transparency
                end
            })
            
            -- Visualise Toggle
            local visualiseToggle = section:toggle({
                name = "Visualise", 
                flag = "silent_visualise_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.visualiseEnabled = bool
                    if not bool then
                        destroyVisuals()
                    end
                end,
                seperator = true
            })
            
            -- Visualise Settings Sub-section
            local visualiseSubSection = visualiseToggle:settings({})
            
            -- Highlight Toggle
            local highlightToggle = visualiseSubSection:toggle({
                name = "Highlight", 
                flag = "silent_highlight_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.highlightEnabled = bool
                    if not bool and esp then
                        esp:Destroy()
                        esp = nil
                    end
                end,
                seperator = true
            })
            
            highlightToggle:colorpicker({
                name = "Fill Color",
                flag = "silent_highlight_fill",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.highlightFillColor = color
                    silentSettings.highlightFillTransparency = transparency
                    if esp then
                        esp.FillColor = color
                        esp.FillTransparency = transparency
                    end
                end
            })
            
            highlightToggle:colorpicker({
                name = "Outline Color",
                flag = "silent_highlight_outline",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.highlightOutlineColor = color
                    silentSettings.highlightOutlineTransparency = transparency
                    if esp then
                        esp.OutlineColor = color
                        esp.OutlineTransparency = transparency
                    end
                end
            })
            
            -- Tracer Toggle
            local tracerToggle = visualiseSubSection:toggle({
                name = "Tracer", 
                flag = "silent_tracer_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.tracerEnabled = bool
                    if not bool then
                        tracerLine.Visible = false
                    end
                end,
                seperator = true
            })
            
            tracerToggle:colorpicker({
                name = "Tracer Color",
                flag = "silent_tracer_color",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.tracerColor = color
                    -- Для Drawing API: больше fade = меньше прозрачности (инвертируем)
                    silentSettings.tracerTransparency = 1 - transparency
                    tracerLine.Color = color
                    tracerLine.Transparency = 1 - transparency
                end
            })
            
            -- Aimpart Dropdown
            section:dropdown({
                name = "Aimpart",
                flag = "silent_aimpart",
                items = {
                    "Head",
                    "UpperTorso", 
                    "LowerTorso",
                    "LeftUpperArm",
                    "LeftLowerArm",
                    "LeftHand",
                    "RightUpperArm",
                    "RightLowerArm", 
                    "RightHand",
                    "LeftUpperLeg",
                    "LeftLowerLeg",
                    "LeftFoot",
                    "RightUpperLeg",
                    "RightLowerLeg",
                    "RightFoot"
                },
                default = "Head",
                callback = function(selected)
                    silentSettings.targetPart = selected
                end,
                seperator = true
            })
            
            
            -- Checks Toggle
            local checksToggle = section:toggle({
                name = "Checks", 
                flag = "silent_checks_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checksEnabled = bool
                end,
                seperator = true
            })
            
            -- Checks Settings Sub-section
            local checksSubSection = checksToggle:settings({})
            
            -- KO Check
            checksSubSection:toggle({
                name = "Check K.O",
                flag = "silent_check_ko",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkKO = bool
                end,
                seperator = true
            })
            
            -- Grabbed Check
            checksSubSection:toggle({
                name = "Check Grabbed",
                flag = "silent_check_grabbed",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkGrabbed = bool
                end,
                seperator = true
            })
            
            -- ForceField Check
            checksSubSection:toggle({
                name = "Check ForceField",
                flag = "silent_check_forcefield",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkForceField = bool
                end,
                seperator = true
            })
            
            -- Wall Check
            checksSubSection:toggle({
                name = "Check Wall",
                flag = "silent_check_wall",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkWall = bool
                end,
                seperator = true
            })
            
            -- Prediction Toggle
            local predictionToggle = section:toggle({
                name = "Prediction", 
                flag = "silent_prediction_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.predictionEnabled = bool
                end,
                seperator = true
            })
            
            -- Prediction Settings Sub-section
            local predictionSubSection = predictionToggle:settings({})
            
            -- Prediction X Textbox
            predictionSubSection:textbox({
                name = "Prediction X",
                flag = "silent_prediction_x",
                placeholder = "0.021111111",
                callback = function(text)
                    local value = tonumber(text)
                    if value then
                        silentSettings.customPredictionX = value
                    end
                end,
                seperator = true
            })
            
            -- Prediction Y Textbox
            predictionSubSection:textbox({
                name = "Prediction Y",
                flag = "silent_prediction_y",
                placeholder = "0.0102",
                callback = function(text)
                    local value = tonumber(text)
                    if value then
                        silentSettings.customPredictionY = value
                    end
                end,
                seperator = true
            })
            
            -- Resolver Toggle
            local resolverToggle = section:toggle({
                name = "Resolver", 
                flag = "silent_resolver_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.resolverEnabled = bool
                end,
                seperator = true
            })
            
            -- Resolver Settings Sub-section
            local resolverSubSection = resolverToggle:settings({})
            
            -- Resolver Mode Dropdown
            resolverSubSection:dropdown({
                name = "Resolver Mode",
                flag = "silent_resolver_mode",
                items = {
                    "Velocity",
                    "MoveDirection", 
                    "CalculateCFrame"
                },
                default = "Velocity",
                callback = function(selected)
                    silentSettings.resolverMode = selected
                end,
                seperator = true
            })
            
            -- Main Loop
            run.RenderStepped:Connect(function()
                if fovFrame and silentSettings.showFov and silentSettings.useFov then
                    local mousePos = uis:GetMouseLocation()
                    fovFrame.Position = udim2_offset(mousePos.X, mousePos.Y - gui_offset)
                    fovFrame.Visible = true
                else
                    fovFrame.Visible = false
                end
                
                if not silentSettings.enabled then
                    destroyVisuals()
                    return
                end
                
                local target = getTarget()
                if target then
                    local predictedPosition = _G.silentUtility:predict(target, silentSettings.predictionX, silentSettings.predictionY)
                    if predictedPosition then
                        highlightPlayer(target)
                        updateTracer(predictedPosition)
                    else
                        destroyVisuals()
                    end
                else
                    destroyVisuals()
                end
            end)
            
            -- AIMBOT HOOK
            local __aimbot
            __aimbot = hookmetamethod(game, "__index", newcclosure(function(t, k)
                if t:IsA("Mouse") and (k == "Hit" or k == "Target") then
                    if not (silentSettings.enabled and getTarget()) then
                        return __aimbot(t, k)
                    end
                    
                    local target = getTarget()
                    if target then
                        local predictedPosition = _G.silentUtility:predict(target, silentSettings.predictionX, silentSettings.predictionY)
                        if predictedPosition then
                            local hit = cfr(predictedPosition)
                            return k == "Hit" and hit or target
                        end
                    end
                end
                return __aimbot(t, k)
            end))
            
        end
    end
    
    -- Other Section
    do
        local OtherSection = OtherTab:column({})
        local section = OtherSection:section({name = "Other", default = false})
        
        -- HitboxExpander Toggle
        local hitboxExpanderToggle = section:toggle({
            name = "Hitbox Expander",
            flag = "hitbox_expander_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.hitboxExpanderSettings.enabled = bool
                if bool then
                    _G.StartHitboxExpander()
                else
                    _G.StopHitboxExpander()
                end
            end,
            info = "Увеличивает хитбоксы игроков для упрощения попадания"
        })
        
        -- HitboxExpander Settings
        local hitboxExpanderSettings = hitboxExpanderToggle:settings({})
        
        hitboxExpanderSettings:textbox({
            name = "Hitbox Size",
            flag = "hitbox_expander_size",
            placeholder = "10",
            default = "10",
            callback = function(text)
                local value = tonumber(text)
                if value then
                    _G.hitboxExpanderSettings.size = value
                end
            end,
            info = "Размер увеличенного хитбокса (рекомендуется 5-20)"
        })
        
        hitboxExpanderSettings:toggle({
            name = "Visible Hitboxes",
            flag = "hitbox_expander_visible",
            type = "checkbox",
            default = false,
            callback = function(bool)
                _G.hitboxExpanderSettings.visible = bool
            end,
            info = "Показывать увеличенные хитбоксы визуально"
        })
        
        -- NoRecoil Toggle
        section:toggle({
            name = "No Recoil",
            flag = "no_recoil_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.noRecoilSettings.enabled = bool
            end,
            info = "Убирает отдачу оружия через блокировку CFrame камеры"
        })
        
        -- NoSpread Toggle
        local noSpreadToggle = section:toggle({
            name = "No Spread",
            flag = "no_spread_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.noSpreadSettings.enabled = bool
            end,
            info = "Убирает разброс оружия через хук math.random"
        })
        
        -- NoSpread Settings
        local noSpreadSettings = noSpreadToggle:settings({})
        
        noSpreadSettings:slider({
            name = "Spread Amount",
            flag = "no_spread_amount",
            min = 0,
            max = 100,
            default = 0,
            interval = 1,
            suffix = "%",
            callback = function(value)
                _G.noSpreadSettings.amount = value
            end,
            info = "Сила разброса (0% = нет разброса, 100% = полный разброс)"
        })
    end
end

-- // Visuals Tab  
do
    local VisualsTab = window:tab({
        name = "Visuals", 
        icon = "rbxassetid://10723346959"  -- lucide-eye
    })
    
    -- Visuals Section
    do
        local VisualsSection = VisualsTab:column({})
        local section = VisualsSection:section({name = "Visuals", default = false})
        
        -- Placeholder for visual features
        section:label({text = "Visual features will be added here"})
    end
end

-- // Misc Tab
do
    local MiscTab, LoadoutTab, MovementTab = window:tab({
        name = "Misc", 
        icon = "rbxassetid://10734934585",  -- lucide-rocket
        tabs = {"General", "Loadout", "Movement"}
    })
    
    -- General Misc Section
    do
        local MiscSection = MiscTab:column({})
        local section = MiscSection:section({name = "General", default = false})
        
        -- AntiStomp Toggle
        local antiStompToggle = section:toggle({
            name = "AntiStomp",
            flag = "anti_stomp_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.antiStompSettings.enabled = bool
                if bool then
                    _G.StartAntiStomp()
                else
                    _G.StopAntiStomp()
                end
            end,
            info = "Автоматически вызывает смерть при низком HP"
        })
        
        -- AntiStomp Settings
        local antiStompSettings = antiStompToggle:settings({})
        
        antiStompSettings:slider({
            name = "HP Threshold",
            flag = "anti_stomp_hp",
            min = 1,
            max = 99,
            default = 10,
            suffix = " HP",
            callback = function(value)
                _G.antiStompSettings.hpThreshold = value
            end,
            info = "HP при котором будет вызвана смерть"
        })
        
        -- VelocityBreaker Toggle
        local velocityBreakerToggle = section:toggle({
            name = "VelocityBreaker",
            flag = "velocity_breaker_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.velocityBreakerSettings.enabled = bool
                if bool then
                    _G.StartVelocityBreaker()
                else
                    _G.StopVelocityBreaker()
                end
            end,
            info = "Изменяет скорость игрока для анти-эйма"
        })
        
        -- VelocityBreaker Settings
        local velocityBreakerSettings = velocityBreakerToggle:settings({})
        
        velocityBreakerSettings:slider({
            name = "Velocity X",
            flag = "velocity_breaker_x",
            min = 0,
            max = 100,
            default = 0,
            callback = function(value)
                _G.velocityBreakerSettings.velocityX = value
            end,
            info = "Скорость по оси X"
        })
        
        velocityBreakerSettings:slider({
            name = "Velocity Y",
            flag = "velocity_breaker_y",
            min = 0,
            max = 100,
            default = 0,
            callback = function(value)
                _G.velocityBreakerSettings.velocityY = value
            end,
            info = "Скорость по оси Y"
        })
        
        velocityBreakerSettings:slider({
            name = "Velocity Z",
            flag = "velocity_breaker_z",
            min = 0,
            max = 100,
            default = 0,
            callback = function(value)
                _G.velocityBreakerSettings.velocityZ = value
            end,
            info = "Скорость по оси Z"
        })
        
        -- AntiFling Toggle
        section:toggle({
            name = "AntiFling",
            flag = "anti_fling_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.antiFlingSettings.enabled = bool
                if bool then
                    _G.StartAntiFling()
                else
                    _G.StopAntiFling()
                end
            end,
            info = "Отключает коллизии других игроков для предотвращения флинга"
        })
        
        -- AntiInertia Toggle
        section:toggle({
            name = "Anti Inertia",
            flag = "anti_inertia_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.ToggleAntiInertia(bool)
            end,
            info = "Убирает инерцию движения для более точного контроля"
        })
        
        -- LagSwitch Toggle
        local lagSwitchToggle = section:toggle({
            name = "LagSwitch",
            flag = "lag_switch_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.lagSwitchSettings.enabled = bool
                if bool then
                    _G.StartLagSwitch()
                else
                    _G.StopLagSwitch()
                end
            end,
            info = "Создает лаг-десинк для анти-эйма через изменение сетевых флагов"
        })
        
        -- LagSwitch Settings
        local lagSwitchSettings = lagSwitchToggle:settings({})
        
        lagSwitchSettings:slider({
            name = "Desync Delay",
            flag = "lag_switch_desync_delay",
            min = 0.1,
            max = 5.0,
            default = 1.2,
            interval = 0.1,
            suffix = "s",
            callback = function(value)
                _G.lagSwitchSettings.desyncDelay = value
            end,
            info = "Задержка между циклами десинка (фриз + анфриз + пауза)"
        })
    end
    
    -- Loadout Section
    do
        local LoadoutSection = LoadoutTab:column({})
        local section = LoadoutSection:section({name = "Auto Buy", default = true})
        
        -- AutoArmor Toggle
        local autoArmorToggle = section:toggle({
            name = "AutoArmor",
            flag = "auto_armor_enabled",
            type = "toggle",
            callback = function(bool)
                _G.autoBuySettings.autoArmor.enabled = bool
                if bool then
                    _G.StartAutoBuy()
                else
                    _G.StopAutoBuy()
                end
            end,
        })
        
        -- AutoArmor Settings
        local armorSettings = autoArmorToggle:settings({})
        armorSettings:keybind({
            name = "Auto Armor Key",
            flag = "auto_armor_key",
            key = enum.KeyCode.F1,
            mode = "Toggle",
            callback = function(active)
                library.config_flags["auto_armor_enabled"](active)
                _G.autoBuySettings.autoArmor.enabled = active
                if active then
                    _G.StartAutoBuy()
                else
                    _G.StopAutoBuy()
                end
            end
        })
        
        armorSettings:slider({
            name = "Armor Value",
            flag = "auto_armor_value",
            min = 1,
            max = 129,
            default = 120,
            suffix = " HP",
            callback = function(value)
                _G.autoBuySettings.autoArmor.armorValue = value
            end,
            info = "Значение брони при котором будет покупаться новая броня"
        })
        
        -- AutoGuns Toggle
        local autoGunsToggle = section:toggle({
            name = "Auto Guns",
            flag = "auto_guns_enabled",
            type = "toggle",
            callback = function(bool)
                _G.autoBuySettings.autoGuns.enabled = bool
            end
        })
        
        -- AutoGuns Settings
        local gunsSettings = autoGunsToggle:settings({})
        
        gunsSettings:keybind({
            name = "Auto Guns Key",
            flag = "auto_guns_key",
            key = enum.KeyCode.F2,
            mode = "Toggle",
            callback = function(active)
                library.config_flags["auto_guns_enabled"](active)
                _G.autoBuySettings.autoGuns.enabled = active
            end
        })
        
        gunsSettings:dropdown({
            name = "Weapon Selection",
            flag = "auto_guns_weapon",
            items = {
                "[Rifle]", "[LMG]", "[P90]", "[Flintlock]", "[Revolver]", 
                "[Double-Barrel SG]", "[AK47]", "[TacticalShotgun]", 
                "[SMG]", "[AR]", "[Silencer]", "[Shotgun]"
            },
            default = {"[Rifle]", "[LMG]"},
            multi = true,
            callback = function(selectedWeapons)
                _G.autoBuySettings.autoGuns.selectedWeapons = selectedWeapons
                -- Update WEAPONS table to enable only selected weapons
                for _, weaponData in ipairs(_G.WEAPONS or {}) do
                    weaponData.Enabled = false
                    for _, selectedWeapon in ipairs(selectedWeapons) do
                        if weaponData.Name == selectedWeapon then
                            weaponData.Enabled = true
                            break
                        end
                    end
                end
            end,
            info = "Выберите оружие для автопокупки (можно несколько)"
        })
        
        -- AutoAmmo Toggle
        local autoAmmoToggle = section:toggle({
            name = "Auto Ammo",
            flag = "auto_ammo_enabled",
            type = "toggle",
            callback = function(bool)
                _G.autoBuySettings.autoAmmo.enabled = bool
            end
        })
        
        -- AutoAmmo Settings
        local ammoSettings = autoAmmoToggle:settings({})
        
        ammoSettings:keybind({
            name = "Auto Ammo Key",
            flag = "auto_ammo_key",
            key = enum.KeyCode.F3,
            mode = "Toggle",
            callback = function(active)
                library.config_flags["auto_ammo_enabled"](active)
                _G.autoBuySettings.autoAmmo.enabled = active
            end
        })
    end
    
    -- Movement Section
    do
        local MovementSection = MovementTab:column({})
        local section = MovementSection:section({name = "Movement", default = false})
        
        -- SpeedHack Toggle
        local speedHackToggle = section:toggle({
            name = "SpeedHack",
            flag = "speed_hack_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.speedHackSettings.enabled = bool
                if bool then
                    _G.StartSpeedHack()
                else
                    _G.StopSpeedHack()
                end
            end,
            info = "Увеличивает скорость передвижения через CFrame"
        })
        
        -- SpeedHack Settings
        local speedHackSettings = speedHackToggle:settings({})
        
        speedHackSettings:textbox({
            name = "Speed Value",
            flag = "speed_hack_value",
            placeholder = "1",
            default = "1",
            callback = function(text)
                local value = tonumber(text)
                if value then
                    _G.speedHackSettings.speed = value
                end
            end,
            info = "Значение скорости (рекомендуется 1-5)"
        })
        
        speedHackSettings:keybind({
            name = "SpeedHack Key",
            flag = "speed_hack_key",
            key = enum.KeyCode.LeftShift,
            mode = "Toggle",
            default = false,
            callback = function(active)
                -- Кейбинд переключает состояние основного тогла
                library.config_flags["speed_hack_enabled"](active)
                _G.speedHackSettings.enabled = active
                if active then
                    _G.StartSpeedHack()
                else
                    _G.StopSpeedHack()
                end
            end,
            info = "Клавиша для переключения SpeedHack"
        })
        
        -- FlyHack Toggle
        local flyHackToggle = section:toggle({
            name = "FlyHack",
            flag = "fly_hack_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.flyHackSettings.enabled = bool
                if bool then
                    _G.StartFlyHack()
                else
                    _G.StopFlyHack()
                end
            end,
            info = "Позволяет летать с помощью CFrame (Space - вверх, Shift - вниз)"
        })
        
        -- FlyHack Settings
        local flyHackSettings = flyHackToggle:settings({})
        
        flyHackSettings:textbox({
            name = "Fly Speed",
            flag = "fly_hack_speed",
            placeholder = "50",
            default = "50",
            callback = function(text)
                local value = tonumber(text)
                if value then
                    _G.flyHackSettings.speed = value
                end
            end,
            info = "Скорость полета (рекомендуется 30-100)"
        })
        
        flyHackSettings:keybind({
            name = "FlyHack Key",
            flag = "fly_hack_key",
            key = enum.KeyCode.F,
            mode = "Toggle",
            default = false,
            callback = function(active)
                -- Кейбинд переключает состояние основного тогла
                library.config_flags["fly_hack_enabled"](active)
                _G.flyHackSettings.enabled = active
                if active then
                    _G.StartFlyHack()
                else
                    _G.StopFlyHack()
                end
            end,
            info = "Клавиша для переключения FlyHack"
        })
        
        -- NoJumpCooldown Toggle
        section:toggle({
            name = "No Jump Cooldown",
            flag = "no_jump_cooldown_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.noJumpCooldownSettings.enabled = bool
            end,
            info = "Убирает кулдаун прыжка через хук __newindex"
        })
    end
end

-- // Settings Tab
do
    
    local SettingsTab, ConfigsTab = window:tab({
        name = "Settings", 
        icon = "rbxassetid://10734950309",  -- lucide-settings
        tabs = {"Main", "Configs"}
    })
    
    -- Settings Section
    do
        local SettingsSection = SettingsTab:column({})
        local section = SettingsSection:section({name = "Settings", default = false})
        
        -- Set default accent color
        library:update_theme("accent", rgb(0, 169, 255))
        
        -- Menu Keybind
        section:keybind({
            name = "Menu Keybind", 
            key = Enum.KeyCode.RightControl,
            mode = "Toggle",
            default = false,
            callback = function(bool) 
                window.toggle_menu(bool) 
            end,
            info = "Клавиша для открытия/закрытия меню"
        })
        
        -- Game Interaction Buttons
        section:button({
            name = "Copy JobId",
            callback = function()
                setclipboard(game.JobId)
                library.notifications:create_notification({
                    name = "JobId Copied",
                    info = "JobId copied to clipboard!",
                    lifetime = 3
                })
            end,
            info = "Copy current server JobId to clipboard"
        })
        
        section:button({
            name = "Copy GameID",
            callback = function()
                setclipboard(game.GameId)
                library.notifications:create_notification({
                    name = "GameID Copied",
                    info = "GameID copied to clipboard!",
                    lifetime = 3
                })
            end,
            info = "Copy current game ID to clipboard"
        })
        
        section:button({
            name = "Copy Join Script",
            callback = function()
                setclipboard(
                    'game:GetService("TeleportService"):TeleportToPlaceInstance(' ..
                        game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)'
                )
                library.notifications:create_notification({
                    name = "Join Script Copied",
                    info = "Join script copied to clipboard!",
                    lifetime = 3
                })
            end,
            info = "Copy teleport script to join this server"
        })
        
        section:button({
            name = "Rejoin",
            callback = function()
                game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, lp)
            end,
            info = "Rejoin current server"
        })
        
        section:button({
            name = "Join New Server",
            callback = function()
                local serverData = 
                    http_service:JSONDecode(
                    game:HttpGetAsync(
                        "https://games.roblox.com/v1/games/" ..
                            game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
                    )
                )
                local validServers = {}
                for _, server in pairs(serverData.data) do
                    if server.playing >= library.flags["min_players"] and server.playing <= library.flags["max_players"] then
                        insert(validServers, server)
                    end
                end
                
                if #validServers > 0 then
                    local randomServer = validServers[random(1, #validServers)]
                    game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, randomServer.id)
                else
                    library.notifications:create_notification({
                        name = "No Servers Found",
                        info = "No servers found matching player count criteria!",
                        lifetime = 3
                    })
                end
            end,
            info = "Join a random server within player count range"
        })
        
        section:slider({
            name = "Min Players", 
            flag = "min_players", 
            min = 0, 
            max = 40, 
            default = 1, 
            interval = 1,
            info = "Minimum number of players required on server"
        })
        
        section:slider({
            name = "Max Players", 
            flag = "max_players", 
            min = 0, 
            max = 40, 
            default = 15, 
            interval = 1,
            info = "Maximum number of players allowed on server"
        })
        
        -- Notification Test Button
        section:button({
            name = "Notification Test", 
            callback = function()
                library.notifications:create_notification({
                    name = "Test Notification",
                    info = "This is a test notification with random colors!",
                    lifetime = 5
                })
            end
        })
    end
    
    -- Configs Section
    do
        local ConfigsSection = ConfigsTab:column({})
        local section = ConfigsSection:section({name = "Configs", default = true})
        
        local ConfigName = ""
        local ConfigSelected = ""
        
        -- Config List
        local configList = section:dropdown({
            name = "Configs",
            items = {"Default Config"},
            callback = function(selected)
                ConfigSelected = selected
                print("Config Selected:", selected)
            end,
            flag = "config_list"
        })
        
        -- Config Name Input
        section:textbox({
            name = "Config Name", 
            placeholder = "Enter config name...",
            callback = function(text)
                ConfigName = text
            end,
            flag = "config_name_input"
        })
        
        -- Create Config Button
        section:button({
            name = "Create Config", 
            callback = function()
                if ConfigName ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigName .. ".cfg"
                    if not isfile(configPath) then
                        writefile(configPath, library:get_config())
                        
                        -- Обновляем dropdown
                        local configFiles = {}
                        for idx, file in listfiles(library.directory .. "/configs") do
                            local name = file:gsub(library.directory .. "/configs\\", ""):gsub(".cfg", ""):gsub(library.directory .. "\\configs\\", "")
                            insert(configFiles, name)
                        end
                        configList.refresh_options(configFiles)
                        
                        library.notifications:create_notification({
                            name = "Config Created",
                            info = "Config '" .. ConfigName .. "' created successfully!",
                            lifetime = 3
                        })
                    else
                        library.notifications:create_notification({
                            name = "Error",
                            info = "Config '" .. ConfigName .. "' already exists!",
                            lifetime = 3
                        })
                    end
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please enter a config name!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Load Config Button
        section:button({
            name = "Load Config", 
            callback = function()
                if ConfigSelected ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigSelected .. ".cfg"
                    if isfile(configPath) then
                        library:load_config(readfile(configPath))
                        library.notifications:create_notification({
                            name = "Config Loaded",
                            info = "Config '" .. ConfigSelected .. "' loaded successfully!",
                            lifetime = 3
                        })
                    else
                        library.notifications:create_notification({
                            name = "Error",
                            info = "Config file not found!",
                            lifetime = 3
                        })
                    end
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please select a config to load!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Save Config Button
        section:button({
            name = "Save Config", 
            callback = function()
                if ConfigSelected ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigSelected .. ".cfg"
                    writefile(configPath, library:get_config())
                    library.notifications:create_notification({
                        name = "Config Saved",
                        info = "Config '" .. ConfigSelected .. "' saved successfully!",
                        lifetime = 3
                    })
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please select a config to save!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Delete Config Button
        section:button({
            name = "Delete Config", 
            callback = function()
                if ConfigSelected ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigSelected .. ".cfg"
                    if isfile(configPath) then
                        delfile(configPath)
                        
                        -- Обновляем dropdown
                        local configFiles = {}
                        for idx, file in listfiles(library.directory .. "/configs") do
                            local name = file:gsub(library.directory .. "/configs\\", ""):gsub(".cfg", ""):gsub(library.directory .. "\\configs\\", "")
                            insert(configFiles, name)
                        end
                        
                        if #configFiles > 0 then
                            configList.refresh_options(configFiles)
                        else
                            configList.refresh_options({"No configs found"})
                        end
                        
                        library.notifications:create_notification({
                            name = "Config Deleted",
                            info = "Config '" .. ConfigSelected .. "' deleted successfully!",
                            lifetime = 3
                        })
                        ConfigSelected = ""
                    else
                        library.notifications:create_notification({
                            name = "Error",
                            info = "Config file not found!",
                            lifetime = 3
                        })
                    end
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please select a config to delete!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Auto refresh function
        local function refreshConfigList(showNotification)
            local configFiles = {}
            for idx, file in listfiles(library.directory .. "/configs") do
                local name = file:gsub(library.directory .. "/configs\\", ""):gsub(".cfg", ""):gsub(library.directory .. "\\configs\\", "")
                insert(configFiles, name)
            end
            
            if #configFiles > 0 then
                configList.refresh_options(configFiles)
            else
                configList.refresh_options({"No configs found"})
            end
            
            if showNotification then
                library.notifications:create_notification({
                    name = "Configs Refreshed",
                    info = "Config list updated!",
                    lifetime = 2
                })
            end
        end
        
        -- Auto refresh on startup
        refreshConfigList(false)
        
        -- Refresh Configs Button
        section:button({
            name = "Refresh Configs", 
            callback = function()
                refreshConfigList(true)
            end
        })
    end
end


library:update_theme("accent", rgb(0, 169, 255))
