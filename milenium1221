-- // Variables
local uis = game:GetService("UserInputService")
local players = game:GetService("Players")
local ws = game:GetService("Workspace")
local rs = game:GetService("ReplicatedStorage")
local http_service = game:GetService("HttpService")
local gui_service = game:GetService("GuiService")
local lighting = game:GetService("Lighting")
local run = game:GetService("RunService")
local stats = game:GetService("Stats")
local coregui = game:GetService("CoreGui")
local debris = game:GetService("Debris")
local tween_service = game:GetService("TweenService")
local sound_service = game:GetService("SoundService")

local vec2 = Vector2.new
local vec3 = Vector3.new
local dim2 = UDim2.new
local dim = UDim.new 
local rect = Rect.new
local cfr = CFrame.new
local empty_cfr = cfr()
local point_object_space = empty_cfr.PointToObjectSpace
local angle = CFrame.Angles
local dim_offset = UDim2.fromOffset

local color = Color3.new
local rgb = Color3.fromRGB
local hex = Color3.fromHex
local hsv = Color3.fromHSV
local rgbseq = ColorSequence.new
local rgbkey = ColorSequenceKeypoint.new
local numseq = NumberSequence.new
local numkey = NumberSequenceKeypoint.new

local camera = ws.CurrentCamera
local lp = players.LocalPlayer 
local mouse = lp:GetMouse() 
local gui_offset = gui_service:GetGuiInset().Y

local max = math.max 
local floor = math.floor 
local min = math.min 
local abs = math.abs 
local noise = math.noise
local rad = math.rad 
local random = math.random 
local pow = math.pow 
local sin = math.sin 
local pi = math.pi 
local tan = math.tan 
local atan2 = math.atan2 
local clamp = math.clamp 

local insert = table.insert 
local find = table.find 
local remove = table.remove
local concat = table.concat

-- // AutoBuy Variables
local task_wait = task.wait
local task_spawn = task.spawn
local task_cancel = task.cancel

-- // Silent Aimbot Variables
local drawing_new = Drawing.new
local hookmetamethod = hookmetamethod
local newcclosure = newcclosure
local getnamecallmethod = getnamecallmethod
local checkcaller = checkcaller
local game = game
local enum = Enum
local instance_new = Instance.new
local udim2_new = UDim2.new
local udim2_offset = UDim2.fromOffset

-- // Library
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/Library/refs/heads/main/v5"))()

-- // FFlags Normalization
do
    local function checkFFlags()
        -- Нормализация флагов при запуске скрипта
        local maxBandwidth = getfflag("PhysicsSenderMaxBandwidthBps")
        if maxBandwidth ~= 13 then
            setfflag("PhysicsSenderMaxBandwidthBps", "13")
            print("ФлагПрименен" .. maxBandwidth)
        end
        
        local senderRate = getfflag("S2PhysicsSenderRate")
        if senderRate ~= 1 then
            setfflag("S2PhysicsSenderRate", "1")
            print("ФлагПрименен" .. senderRate)
        end
    end
    
    -- Вызываем нормализацию при запуске скрипта
    checkFFlags()
end

-- // Utility Functions
do
    local utility = {}
    
    function utility:predict(targetPart, predictionX, predictionY)
        if not targetPart then return nil end
        local velocity = targetPart.Velocity or vec3(0, 0, 0)
        return targetPart.Position + vec3(
            velocity.X * predictionX,
            velocity.Y * predictionY,
            velocity.Z * predictionX
        )
    end
    
    function utility:isPlayerKO(player)
        if not player or not player.Character then return false end
        
        -- Проверяем K.O статус через BodyEffects
        local success, isKO = pcall(function()
            local playerInWorkspace = workspace.Players:FindFirstChild(player.Name)
            if playerInWorkspace and playerInWorkspace:FindFirstChild("BodyEffects") then
                local koEffect = playerInWorkspace.BodyEffects:FindFirstChild("K.O")
                if koEffect and koEffect:FindFirstChild("Value") then
                    return koEffect.Value.Value == true
                end
            end
            return false
        end)
        
        if success then
            return isKO
        end
        
        -- Fallback к проверке здоровья если BodyEffects недоступны
        local humanoid = player.Character:FindFirstChild("Humanoid")
        return humanoid and humanoid.Health <= 0
    end
    
    function utility:isPlayerGrabbed(player)
        if not player or not player.Character then return false end
        -- Проверяем, схвачен ли игрок
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid then
            return humanoid.PlatformStand or false
        end
        return false
    end
    
    function utility:hasForceField(player)
        if not player or not player.Character then return false end
        return player.Character:FindFirstChildOfClass("ForceField") ~= nil
    end
    
    function utility:hasWallBetween(fromPosition, toPosition, targetPlayer)
        if not fromPosition or not toPosition or not targetPlayer then return false end
        
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        raycastParams.FilterDescendantsInstances = {targetPlayer.Character, lp.Character}
        
        local direction = (toPosition - fromPosition)
        
        local raycastResult = workspace:Raycast(fromPosition, direction, raycastParams)
        return raycastResult ~= nil
    end
    
    function utility:getClosestPlayer(fovRadius, targetPart, useFov, checks, predX, predY)
        local closestPlayer, closestDistance = nil, math.huge
        
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= lp and player.Character and player.Character:FindFirstChild(targetPart) then
                -- Проверки цели (только при выборе новой цели)
                local skipPlayer = false
                if checks then
                    if checks.checkKO and utility:isPlayerKO(player) then
                        skipPlayer = true
                    elseif checks.checkGrabbed and utility:isPlayerGrabbed(player) then
                        skipPlayer = true
                    elseif checks.checkForceField and utility:hasForceField(player) then
                        skipPlayer = true
                    elseif checks.checkWall and utility:hasWallBetween(camera.CFrame.Position, player.Character[targetPart].Position, player) then
                        skipPlayer = true
                    end
                end
                
                if not skipPlayer then
                    local part = player.Character[targetPart]
                    local predictedPosition = utility:predict(part, predX or 0.021111111, predY or 0.0102)
                    if predictedPosition then
                        local screenPos, onScreen = camera:WorldToViewportPoint(predictedPosition)
                        if onScreen then
                            local mousePos = uis:GetMouseLocation()
                            local distance = (vec2(screenPos.X, screenPos.Y) - mousePos).Magnitude
                            
                            if useFov then
                                if distance < fovRadius and distance < closestDistance then
                                    closestPlayer = part
                                    closestDistance = distance
                                end
                            else
                                if distance < closestDistance then
                                    closestPlayer = part
                                    closestDistance = distance
                                end
                            end
                        end
                    end
                end
            end
        end
        return closestPlayer
    end
    
    _G.silentUtility = utility
end

-- // AutoBuy Module
do
    local autoBuySettings = {
        autoArmor = {
            enabled = false,
            armorValue = 120,
            key = enum.KeyCode.F1,
            keyMode = "Toggle"
        },
        autoGuns = {
            enabled = false,
            selectedWeapons = {"[Rifle]", "[LMG]"},
            key = enum.KeyCode.F2,
            keyMode = "Toggle"
        },
        autoAmmo = {
            enabled = false,
            key = enum.KeyCode.F3,
            keyMode = "Toggle"
        }
    }
    
    -- Shop objects
    local Shop = ws.Ignored.Shop
    local ARMOR_SHOP = Shop["[High-Medium Armor] - $2513"]
    local ARMOR_PRICE = 2513
    
    -- Weapons data
    local WEAPONS = {
        {Name = "[Rifle]", ShopName = "[Rifle] - $0", Enabled = true},
        {Name = "[LMG]", ShopName = "[LMG] - $0", Enabled = true},
        {Name = "[P90]", ShopName = "[P90] - $0", Enabled = false},
        {Name = "[Flintlock]", ShopName = "[Flintlock] - $0", Enabled = false},
        {Name = "[Revolver]", ShopName = "[Revolver] - $0", Enabled = false},
        {Name = "[Double-Barrel SG]", ShopName = "[Double-Barrel SG] - $0", Enabled = false},
        {Name = "[AK47]", ShopName = "[AK47] - $0", Enabled = false},
        {Name = "[TacticalShotgun]", ShopName = "[TacticalShotgun] - $0", Enabled = false},
        {Name = "[SMG]", ShopName = "[SMG] - $0", Enabled = false},
        {Name = "[AR]", ShopName = "[AR] - $0", Enabled = false},
        {Name = "[Silencer]", ShopName = "[Silencer] - $0", Enabled = false},
        {Name = "[Shotgun]", ShopName = "[Shotgun] - $0", Enabled = false}
    }
    
    -- Ammo mapping
    local AMMO_MAP = {
        ["[Rifle]"] = "5 [Rifle Ammo] - $0",
        ["[LMG]"] = "200 [LMG Ammo] - $0",
        ["[P90]"] = "120 [P90 Ammo] - $0",
        ["[Flintlock]"] = "6 [Flintlock Ammo] - $0",
        ["[Revolver]"] = "12 [Revolver Ammo] - $0",
        ["[Double-Barrel SG]"] = "18 [Double-Barrel SG Ammo] - $0",
        ["[AK47]"] = "90 [AK47 Ammo] - $0",
        ["[TacticalShotgun]"] = "20 [TacticalShotgun Ammo] - $0",
        ["[SMG]"] = "80 [SMG Ammo] - $0",
        ["[AR]"] = "100 [AR Ammo] - $0",
        ["[Silencer]"] = "25 [Silencer Ammo] - $0",
        ["[Shotgun]"] = "20 [Shotgun Ammo] - $0"
    }
    
    -- Utility functions
    local autoBuyUtility = {}
    
    function autoBuyUtility:hasWeapon(weaponName)
        if lp.Backpack:FindFirstChild(weaponName) then
            return true
        end
        
        local character = lp.Character
        if character and character:FindFirstChild(weaponName) then
            return true
        end
        
        return false
    end
    
    function autoBuyUtility:getWeaponShop(weaponData)
        return Shop:FindFirstChild(weaponData.ShopName)
    end
    
    function autoBuyUtility:hasItem(itemName)
        local function check(container)
            for _, item in pairs(container:GetChildren()) do
                if item.Name == itemName then
                    return true
                end
            end
            return false
        end
        return check(lp.Backpack) or check(lp.Character)
    end
    
    function autoBuyUtility:getAmmoShop(ammoName)
        return Shop:FindFirstChild(ammoName)
    end
    
    -- Auto buy functions
    local function AutoArmor()
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") and lp.Character:FindFirstChild("BodyEffects") then
            local Origin = lp.Character.HumanoidRootPart.CFrame
            local Armor = lp.Character.BodyEffects.Armor
            
            if Armor.Value <= autoBuySettings.autoArmor.armorValue then
                repeat
                    task_wait()    
                    lp.Character.HumanoidRootPart.CFrame = ARMOR_SHOP.Head.CFrame
                    fireclickdetector(ARMOR_SHOP.ClickDetector)
                until Armor.Value >= 130 or lp.DataFolder.Currency.Value < ARMOR_PRICE
                lp.Character.HumanoidRootPart.CFrame = Origin
            end
        end
    end
    
    local function AutoAmmo(weaponName)
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            local ammoName = AMMO_MAP[weaponName]
            if not ammoName then return end
            
            local inventoryItem = lp.DataFolder.Inventory:FindFirstChild(weaponName)
            local currentAmmo = inventoryItem and tonumber(inventoryItem.Value) or 0
            
            if currentAmmo > 0 then
                return
            end
            
            for _, tool in pairs(lp.Character:GetChildren()) do
                if tool:IsA("Tool") then
                    tool.Parent = lp.Backpack
                end
            end
            
            local Origin = lp.Character.HumanoidRootPart.CFrame
            local ammoShop = autoBuyUtility:getAmmoShop(ammoName)
            
            if ammoShop and ammoShop:FindFirstChild("Head") and ammoShop:FindFirstChild("ClickDetector") then
                for i = 1, 2 do
                    local startAmmo = lp.DataFolder.Inventory:FindFirstChild(weaponName)
                    local startValue = startAmmo and tonumber(startAmmo.Value) or 0
                    
                    repeat
                        task_wait()
                        lp.Character.HumanoidRootPart.CFrame = ammoShop.Head.CFrame
                        fireclickdetector(ammoShop.ClickDetector)
                        
                        local newAmmo = lp.DataFolder.Inventory:FindFirstChild(weaponName)
                        local newValue = newAmmo and tonumber(newAmmo.Value) or 0
                    until newValue > startValue
                end
                
                lp.Character.HumanoidRootPart.CFrame = Origin
            end
        end
    end
    
    local function AutoWeaponsAndAmmo()
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            for _, weaponData in ipairs(WEAPONS) do
                if weaponData.Enabled then
                
                if not autoBuyUtility:hasWeapon(weaponData.Name) then
                    local s, e = pcall(function()
                        local Origin = lp.Character.HumanoidRootPart.CFrame
                        local weaponShop = autoBuyUtility:getWeaponShop(weaponData)
                        
                        if weaponShop and weaponShop:FindFirstChild("Head") and weaponShop:FindFirstChild("ClickDetector") then
                            repeat
                                task_wait()
                                lp.Character.HumanoidRootPart.CFrame = weaponShop.Head.CFrame
                                fireclickdetector(weaponShop.ClickDetector)
                            until autoBuyUtility:hasWeapon(weaponData.Name)
                            
                            lp.Character.HumanoidRootPart.CFrame = Origin
                        end
                    end)
                    if not s then warn("[AutoBuy] Weapon buy error:", weaponData.Name, e) end
                end
                
                if autoBuyUtility:hasWeapon(weaponData.Name) then
                    local s, e = pcall(AutoAmmo, weaponData.Name)
                    if not s then warn("[AutoBuy] Ammo buy error:", weaponData.Name, e) end
                end
                end
            end
        end
    end
    
    local autoBuyConnection = nil
    
    -- Main loop
    local function StartAutoBuy()
        if autoBuyConnection then
            autoBuyConnection = nil
        end
        
        autoBuyConnection = coroutine.create(function()
            while task_wait() do
                if autoBuySettings.autoArmor.enabled then
                    local s, e = pcall(AutoArmor)
                    if not s then warn("[AutoBuy] Armor error:", e) end
                end
                
                if autoBuySettings.autoGuns.enabled and lp.Character then
                    local s2, e2 = pcall(AutoWeaponsAndAmmo)
                    if not s2 then warn("[AutoBuy] weapons/ammo error:", e2) end
                end
                
                if autoBuySettings.autoAmmo.enabled and lp.Character then
                    -- Auto ammo only for existing weapons
                    for _, weaponData in ipairs(WEAPONS) do
                        if autoBuyUtility:hasWeapon(weaponData.Name) then
                            local s3, e3 = pcall(AutoAmmo, weaponData.Name)
                            if not s3 then warn("[AutoBuy] Ammo buy error:", weaponData.Name, e3) end
                        end
                    end
                end
            end
        end)
        
        coroutine.resume(autoBuyConnection)
    end
    
    local function StopAutoBuy()
        if autoBuyConnection then
            autoBuyConnection = nil
        end
    end
    
    _G.autoBuySettings = autoBuySettings
    _G.autoBuyUtility = autoBuyUtility
    _G.StartAutoBuy = StartAutoBuy
    _G.StopAutoBuy = StopAutoBuy
    _G.WEAPONS = WEAPONS
    
    -- ✅ НЕ ЗАПУСКАЕМ АВТОМАТИЧЕСКИ!
end

-- // AntiStomp Module
do
    local antiStompSettings = {
        enabled = false,
        hpThreshold = 10
    }
    
    local antiStompConnection = nil
    
    local function StartAntiStomp()
        if antiStompConnection then
            antiStompConnection = nil
        end
        
        antiStompConnection = coroutine.create(function()
            while true do
                wait(0.1)
                
                if antiStompSettings.enabled and lp.Character then
                    local humanoid = lp.Character:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health <= antiStompSettings.hpThreshold then
                        -- Вызываем смерть локального игрока
                        humanoid.Health = 0
                    end
                end
            end
        end)
        
        coroutine.resume(antiStompConnection)
    end
    
    local function StopAntiStomp()
        if antiStompConnection then
            antiStompConnection = nil
        end
    end
    
    _G.antiStompSettings = antiStompSettings
    _G.StartAntiStomp = StartAntiStomp
    _G.StopAntiStomp = StopAntiStomp
    
    -- ✅ НЕ ЗАПУСКАЕМ АВТОМАТИЧЕСКИ!
end

-- // VelocityBreaker Module
do
    local velocityBreakerSettings = {
        enabled = false,
        velocityX = 0,
        velocityY = 0,
        velocityZ = 0
    }
    
    local velocityConnection = nil
    
    local function StartVelocityBreaker()
        if velocityConnection then
            velocityConnection:Disconnect()
            velocityConnection = nil
        end
        
        velocityConnection = run.Heartbeat:Connect(function()
            if velocityBreakerSettings.enabled then
                local character = lp.Character
                if character and character:FindFirstChild("HumanoidRootPart") then
                    local hrp = character.HumanoidRootPart
                    local originalVel = hrp.Velocity
                    hrp.Velocity = vec3(
                        velocityBreakerSettings.velocityX,
                        velocityBreakerSettings.velocityY,
                        velocityBreakerSettings.velocityZ
                    )
                    run.RenderStepped:Wait()
                    hrp.Velocity = originalVel
                end
            end
        end)
    end
    
    local function StopVelocityBreaker()
        if velocityConnection then
            velocityConnection:Disconnect()
            velocityConnection = nil
        end
    end
    
    _G.velocityBreakerSettings = velocityBreakerSettings
    _G.StartVelocityBreaker = StartVelocityBreaker
    _G.StopVelocityBreaker = StopVelocityBreaker
    
    -- ✅ НЕ ЗАПУСКАЕМ АВТОМАТИЧЕСКИ!
end

-- // AntiFling Module
do
    local antiFlingSettings = {
        enabled = false
    }
    
    local antiFlingConnection = nil
    
    local function DisableCollisionsForAllPlayers()
        if not antiFlingSettings.enabled then return end
        
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= lp and player.Character then
                for _, part in ipairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") and part.CanCollide then
                        part.CanCollide = false
                    end
                end
            end
        end
    end
    
    local function RestoreCollisionsForAllPlayers()
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= lp and player.Character then
                for _, part in ipairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") and not part.CanCollide then
                        part.CanCollide = true
                    end
                end
            end
        end
    end
    
    local function StartAntiFling()
        if antiFlingConnection then
            antiFlingConnection:Disconnect()
        end
        
        if not antiFlingSettings.enabled then return end
        
        -- Постоянный мониторинг и отключение коллизий
        antiFlingConnection = run.Heartbeat:Connect(function()
            if antiFlingSettings.enabled then
                DisableCollisionsForAllPlayers()
            end
        end)
    end
    
    local function StopAntiFling()
        if antiFlingConnection then
            antiFlingConnection:Disconnect()
            antiFlingConnection = nil
        end
        
        -- Восстанавливаем коллизии для всех игроков
        RestoreCollisionsForAllPlayers()
    end
    
    _G.antiFlingSettings = antiFlingSettings
    _G.StartAntiFling = StartAntiFling
    _G.StopAntiFling = StopAntiFling
end

-- // AntiInertia Module
do
    local antiInertiaSettings = {
        enabled = false,
        noInertia = true,
        speed = {
            ground = 1.0,
            air = 0.8
        }
    }
    
    local antiInertiaConnection = nil
    
    local function ToggleAntiInertia(state)
        antiInertiaSettings.enabled = state
        if antiInertiaConnection then
            antiInertiaConnection:Disconnect()
            antiInertiaConnection = nil
        end
        
        if state then
            antiInertiaConnection = run.Heartbeat:Connect(function()
                if not antiInertiaSettings.enabled then return end
                
                local character = lp.Character
                if not character or not character:FindFirstChild("HumanoidRootPart") then return end
                
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if not humanoid then return end
                
                local rootPart = character.HumanoidRootPart
                local moveDir = humanoid.MoveDirection
                
                if moveDir.Magnitude > 0 then
                    -- Просто убираем инерцию без изменения скорости
                    if antiInertiaSettings.noInertia then
                        local currentVel = rootPart.Velocity
                        rootPart.Velocity = vec3(currentVel.X, currentVel.Y, currentVel.Z)
                    end
                elseif antiInertiaSettings.noInertia then
                    rootPart.Velocity = vec3(0, rootPart.Velocity.Y, 0)
                end
            end)
        end
    end
    
    _G.antiInertiaSettings = antiInertiaSettings
    _G.ToggleAntiInertia = ToggleAntiInertia
end

-- // LagSwitch Module
do
    local lagSwitchSettings = {
        enabled = false,
        desyncDelay = 1.2  -- задержка между десинком (freezePlayer + unfreeze)
    }
    
    local lagSwitchConnection = nil
    local isInitialized = false
    
    local function checkFFlags()
        -- Нормализация флагов при первом запуске
        local maxBandwidth = getfflag("PhysicsSenderMaxBandwidthBps")
        if maxBandwidth ~= 13 then
            setfflag("PhysicsSenderMaxBandwidthBps", "13")
        end
        
        local senderRate = getfflag("S2PhysicsSenderRate")
        if senderRate ~= 1 then
            setfflag("S2PhysicsSenderRate", "1")
        end
        
        isInitialized = true
    end
    
    local function freezePlayer()
        setfflag("PhysicsSenderMaxBandwidthBps", "1")
        setfflag("S2PhysicsSenderRate", "200")
    end
    
    local function unfreezePlayer()
        setfflag("PhysicsSenderMaxBandwidthBps", "13")
        setfflag("S2PhysicsSenderRate", "1")
    end
    
    local function StartLagSwitch()
        if lagSwitchConnection then
            lagSwitchConnection:Disconnect()
            lagSwitchConnection = nil
        end
        
        if not lagSwitchSettings.enabled then return end
        
        -- Инициализация флагов при первом запуске
        if not isInitialized then
            checkFFlags()
        end
        
        lagSwitchConnection = coroutine.create(function()
            while lagSwitchSettings.enabled do
                -- Фриз игрока
                freezePlayer()
                task_wait(lagSwitchSettings.desyncDelay) -- задержка между freeze и unfreeze (слайдер)
                
                -- Анфриз игрока
                unfreezePlayer()
                task_wait(0.2) -- короткая пауза перед следующим циклом
            end
        end)
        
        coroutine.resume(lagSwitchConnection)
    end
    
    local function StopLagSwitch()
        lagSwitchSettings.enabled = false
        
        if lagSwitchConnection then
            lagSwitchConnection = nil
        end
        
        -- Восстанавливаем нормальные флаги при выключении
        if isInitialized then
            unfreezePlayer()
        end
    end
    
    _G.lagSwitchSettings = lagSwitchSettings
    _G.StartLagSwitch = StartLagSwitch
    _G.StopLagSwitch = StopLagSwitch
end

-- // SpeedHack Module
do
    local speedHackSettings = {
        enabled = false,
        speed = 1
    }
    
    local speedHackConnection = nil
    
    local function hasCharacter(player)
        return player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid")
    end
    
    local function StartSpeedHack()
        if speedHackConnection then
            speedHackConnection:Disconnect()
            speedHackConnection = nil
        end
        
        speedHackConnection = run.Heartbeat:Connect(function(deltaTime)
            if speedHackSettings.enabled and hasCharacter(lp) then
                local speed = speedHackSettings.speed
                local rootPart = lp.Character.HumanoidRootPart
                local humanoid = lp.Character.Humanoid
                
                rootPart.CFrame = rootPart.CFrame + humanoid.MoveDirection * speed
            end
        end)
    end
    
    local function StopSpeedHack()
        if speedHackConnection then
            speedHackConnection:Disconnect()
            speedHackConnection = nil
        end
    end
    
    _G.speedHackSettings = speedHackSettings
    _G.StartSpeedHack = StartSpeedHack
    _G.StopSpeedHack = StopSpeedHack
end

-- // FlyHack Module
do
    local flyHackSettings = {
        enabled = false,
        speed = 50
    }
    
    local flyHackConnection = nil
    
    local function hasCharacter(player)
        return player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid")
    end
    
    local function StartFlyHack()
        if flyHackConnection then
            flyHackConnection:Disconnect()
            flyHackConnection = nil
        end
        
        flyHackConnection = run.Heartbeat:Connect(function(deltaTime)
            if flyHackSettings.enabled and hasCharacter(lp) then
                local moveDirection = lp.Character.Humanoid.MoveDirection
                local hrp = lp.Character.HumanoidRootPart
                local flySpeed = flyHackSettings.speed
                
                -- Вертикальное движение (Space - вверх, LeftShift - вниз)
                local add = vec3(0, (uis:IsKeyDown(enum.KeyCode.Space) and flySpeed / 8 or uis:IsKeyDown(enum.KeyCode.LeftShift) and -flySpeed / 8) or 0, 0)
                
                -- Горизонтальное движение
                hrp.CFrame = hrp.CFrame + (moveDirection * deltaTime) * flySpeed * 10
                hrp.CFrame = hrp.CFrame + add
                hrp.Velocity = (hrp.Velocity * vec3(1, 0, 1)) + vec3(0, 1.9, 0)
            end
        end)
    end
    
    local function StopFlyHack()
        if flyHackConnection then
            flyHackConnection:Disconnect()
            flyHackConnection = nil
        end
    end
    
    _G.flyHackSettings = flyHackSettings
    _G.StartFlyHack = StartFlyHack
    _G.StopFlyHack = StopFlyHack
end

-- // NoJumpCooldown Module
do
    local noJumpCooldownSettings = {
        enabled = false
    }
    
    local noJumpCDOldNewIndex = nil
    
    local function StartNoJumpCooldown()
        -- Ensure game is loaded before hook
        if not game:IsLoaded() then 
            game.Loaded:Wait() 
        end
        
        -- Hook __newindex once, gate by enabled state
        if not noJumpCDOldNewIndex then
            noJumpCDOldNewIndex = hookmetamethod(game, "__newindex", function(self, Index, Value)
                if not checkcaller() and self:IsA("Humanoid") and Index == "JumpPower" and noJumpCooldownSettings.enabled then
                    return
                end
                return noJumpCDOldNewIndex(self, Index, Value)
            end)
        end
    end
    
    local function StopNoJumpCooldown()
        -- Просто отключаем функционал через enabled флаг
        -- Хук остается активным, но не блокирует JumpPower
        noJumpCooldownSettings.enabled = false
    end
    
    -- Инициализируем хук сразу при загрузке модуля
    StartNoJumpCooldown()
    
    _G.noJumpCooldownSettings = noJumpCooldownSettings
    _G.StartNoJumpCooldown = StartNoJumpCooldown
    _G.StopNoJumpCooldown = StopNoJumpCooldown
end

-- // HitboxExpander Module
do
    local hitboxExpanderSettings = {
        enabled = false,
        size = 10,
        visible = false
    }
    
    local hitboxExpandedPlayers = {}
    local hitboxConnection = nil
    
    local function IsKO(player)
        -- Простая проверка на KO - можно расширить при необходимости
        return player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health <= 0
    end
    
    local function ExpandHitbox(player, size, visible)
        if not player.Character then return end
        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        if not hitboxExpandedPlayers[player] then
            hitboxExpandedPlayers[player] = {
                OriginalSize = hrp.Size,
                OriginalTransparency = hrp.Transparency,
                OriginalCanCollide = hrp.CanCollide,
                SelectionBox = nil
            }
        end
        
        local data = hitboxExpandedPlayers[player]
        hrp.Size = vec3(size, size, size)
        hrp.CanCollide = false
        
        if visible then
            hrp.Transparency = 0.5 -- partially transparent so visible but not fully blocking
            if not data.SelectionBox then
                local selBox = instance_new("SelectionBox")
                selBox.Adornee = hrp
                selBox.Color3 = rgb(255, 0, 0)
                selBox.LineThickness = 0.05
                selBox.SurfaceTransparency = 0.7
                selBox.Parent = hrp
                data.SelectionBox = selBox
            end
        else
            hrp.Transparency = 1 -- fully invisible
            if data.SelectionBox then
                data.SelectionBox:Destroy()
                data.SelectionBox = nil
            end
        end
    end
    
    local function ResetHitbox(player)
        if not player.Character then return end
        local hrp = player.Character:FindFirstChild("HumanoidRootPart")
        local data = hitboxExpandedPlayers[player]
        if hrp and data then
            hrp.Size = data.OriginalSize
            hrp.Transparency = data.OriginalTransparency
            hrp.CanCollide = data.OriginalCanCollide
            if data.SelectionBox then
                data.SelectionBox:Destroy()
                data.SelectionBox = nil
            end
            hitboxExpandedPlayers[player] = nil
        end
    end
    
    local function UpdateHitboxes()
        local enabled = hitboxExpanderSettings.enabled
        local size = hitboxExpanderSettings.size
        local visible = hitboxExpanderSettings.visible
        
        for _, player in pairs(players:GetPlayers()) do
            if player ~= lp and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                if enabled and not IsKO(player) then
                    ExpandHitbox(player, size, visible)
                else
                    ResetHitbox(player)
                end
            end
        end
    end
    
    local function StartHitboxExpander()
        if hitboxConnection then
            hitboxConnection:Disconnect()
            hitboxConnection = nil
        end
        
        hitboxConnection = run.Heartbeat:Connect(UpdateHitboxes)
    end
    
    local function StopHitboxExpander()
        if hitboxConnection then
            hitboxConnection:Disconnect()
            hitboxConnection = nil
        end
        
        -- Reset all hitboxes when stopping
        for player, _ in pairs(hitboxExpandedPlayers) do
            ResetHitbox(player)
        end
    end
    
    _G.hitboxExpanderSettings = hitboxExpanderSettings
    _G.StartHitboxExpander = StartHitboxExpander
    _G.StopHitboxExpander = StopHitboxExpander
end

-- // NoRecoil Module
do
    local noRecoilSettings = {
        enabled = false
    }
    
    local noRecoilOldNewIndex = nil
    
    local function isFramework(scr) 
        return tostring(scr) == "Framework" 
    end
    
    local function checkArgs(inst, idx) 
        return tostring(inst):lower():find("camera") and tostring(idx) == "CFrame" 
    end
    
    local function StartNoRecoil()
        -- Ensure game is loaded before hook
        if not game:IsLoaded() then 
            game.Loaded:Wait() 
        end
        
        -- Hook __newindex once, gate by enabled state
        if not noRecoilOldNewIndex then
            noRecoilOldNewIndex = hookmetamethod(game, "__newindex", function(self, idx, val)
                if noRecoilSettings.enabled and isFramework(getcallingscript()) and checkArgs(self, idx) then 
                    return 
                end
                return noRecoilOldNewIndex(self, idx, val)
            end)
        end
    end
    
    local function StopNoRecoil()
        -- Просто отключаем функционал через enabled флаг
        -- Хук остается активным, но не блокирует CFrame
        noRecoilSettings.enabled = false
    end
    
    -- Инициализируем хук сразу при загрузке модуля
    StartNoRecoil()
    
    _G.noRecoilSettings = noRecoilSettings
    _G.StartNoRecoil = StartNoRecoil
    _G.StopNoRecoil = StopNoRecoil
end

-- // NoSpread Module
do
    local noSpreadSettings = {
        enabled = false,
        amount = 0  -- 0-100, lower = less spread
    }
    
    local noSpreadOldRandom = nil
    
    local function StartNoSpread()
        -- Hook math.random once
        if not noSpreadOldRandom then
            noSpreadOldRandom = hookfunction(math.random, function(...)
                local args = {...}
                if checkcaller() then
                    return noSpreadOldRandom(...)
                end
                
                if (#args == 0) or 
                   (args[1] == -0.05 and args[2] == 0.05) or 
                   (args[1] == -0.1) or
                   (args[1] == -0.05) then
                    if noSpreadSettings.enabled then
                        local spread = noSpreadSettings.amount
                        return noSpreadOldRandom(...) * (spread / 100)
                    else
                        return noSpreadOldRandom(...)
                    end
                end
                return noSpreadOldRandom(...)
            end)
        end
    end
    
    local function StopNoSpread()
        -- Просто отключаем функционал через enabled флаг
        -- Хук остается активным, но не изменяет math.random
        noSpreadSettings.enabled = false
    end
    
    -- Инициализируем хук сразу при загрузке модуля
    StartNoSpread()
    
    _G.noSpreadSettings = noSpreadSettings
    _G.StartNoSpread = StartNoSpread
    _G.StopNoSpread = StopNoSpread
end

-- // ESP Framework Module
do
    local espFramework = {}
    local espCache = {}
    local screenGui = nil
    local espConnection = nil
    
    -- // init screengui
    local function initScreenGui()
        if not screenGui then
            screenGui = instance_new("ScreenGui")
            screenGui.Name = "ESPScreenGui"
            screenGui.ResetOnSpawn = false
            screenGui.IgnoreGuiInset = true
            screenGui.Parent = lp:WaitForChild("PlayerGui")
        end
        return screenGui
    end
    
    function espFramework:createBox(player)
        local character = player.Character
        if not character then return end
        
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        local gui = initScreenGui()
        
        -- // box frame
        local box = instance_new("Frame")
        box.Name = "Box_" .. player.Name
        box.BackgroundTransparency = 1
        box.Size = dim2(0, 100, 0, 100)
        box.Position = dim2(0, 0, 0, 0)
        box.BorderSizePixel = 0
        box.Parent = gui
        
        -- // box stroke
        local stroke = instance_new("UIStroke")
        stroke.Name = "Stroke"
        stroke.Thickness = 1.1
        stroke.Color = rgb(255, 255, 255)
        stroke.Parent = box
        
        -- // box gradient
        local gradient = instance_new("UIGradient")
        gradient.Name = "Gradient"
        gradient.Rotation = 90
        gradient.Color = ColorSequence.new({
            rgbkey(0, rgb(255, 255, 255)),
            rgbkey(0.33, rgb(255, 255, 255)),
            rgbkey(0.66, rgb(255, 255, 255)),
            rgbkey(1, rgb(255, 255, 255))
        })
        gradient.Parent = stroke
        
        -- // outline frame
        local outlineFrame = instance_new("Frame")
        outlineFrame.Name = "OutlineFrame"
        outlineFrame.BackgroundTransparency = 1
        outlineFrame.Size = dim2(1, 2, 1, 2)
        outlineFrame.Position = dim2(0, -1, 0, -1)
        outlineFrame.BorderSizePixel = 0
        outlineFrame.Parent = box
        
        local outlineStroke = instance_new("UIStroke")
        outlineStroke.Name = "OutlineStroke"
        outlineStroke.Thickness = 0.9
        outlineStroke.Color = rgb(0, 0, 0)
        outlineStroke.Parent = outlineFrame
        
        -- // inline frame
        local inlineFrame = instance_new("Frame")
        inlineFrame.Name = "InlineFrame"
        inlineFrame.BackgroundTransparency = 1
        inlineFrame.Size = dim2(1, -2, 1, -2)
        inlineFrame.Position = dim2(0, 1, 0, 1)
        inlineFrame.BorderSizePixel = 0
        inlineFrame.Parent = box
        
        local inlineStroke = instance_new("UIStroke")
        inlineStroke.Name = "InlineStroke"
        inlineStroke.Thickness = 0.9
        inlineStroke.Color = rgb(0, 0, 0)
        inlineStroke.Parent = inlineFrame
        
        -- // healthbar outline
        local healthBarOutline = instance_new("Frame")
        healthBarOutline.Name = "HealthBarOutline_" .. player.Name
        healthBarOutline.BackgroundColor3 = rgb(0, 0, 0)
        healthBarOutline.BorderSizePixel = 0
        healthBarOutline.Visible = false
        healthBarOutline.Parent = gui
        
        local healthBarOutlineStroke = instance_new("UIStroke")
        healthBarOutlineStroke.Name = "OutlineStroke"
        healthBarOutlineStroke.Thickness = 0.9
        healthBarOutlineStroke.Color = rgb(0, 0, 0)
        healthBarOutlineStroke.Parent = healthBarOutline
        
        -- // healthbar fill
        local healthBarFill = instance_new("Frame")
        healthBarFill.Name = "HealthBarFill"
        healthBarFill.BackgroundTransparency = 0
        healthBarFill.BorderSizePixel = 0
        healthBarFill.AnchorPoint = vec2(0, 1)
        healthBarFill.Position = dim2(0, 0, 1, 0)
        healthBarFill.Size = dim2(1, 0, 1, 0)
        healthBarFill.Parent = healthBarOutline
        
        local healthBarGradient = instance_new("UIGradient")
        healthBarGradient.Name = "HealthBarGradient"
        healthBarGradient.Rotation = 90
        healthBarGradient.Color = rgbseq({
            rgbkey(0, rgb(0, 255, 0)),
            rgbkey(0.33, rgb(0, 255, 0)),
            rgbkey(0.66, rgb(0, 255, 0)),
            rgbkey(1, rgb(0, 255, 0))
        })
        healthBarGradient.Parent = healthBarFill
        
        -- // armorbar outline
        local armorBarOutline = instance_new("Frame")
        armorBarOutline.Name = "ArmorBarOutline_" .. player.Name
        armorBarOutline.BackgroundColor3 = rgb(0, 0, 0)
        armorBarOutline.BorderSizePixel = 0
        armorBarOutline.Visible = false
        armorBarOutline.Parent = gui
        
        local armorBarOutlineStroke = instance_new("UIStroke")
        armorBarOutlineStroke.Name = "OutlineStroke"
        armorBarOutlineStroke.Thickness = 0.9
        armorBarOutlineStroke.Color = rgb(0, 0, 0)
        armorBarOutlineStroke.Parent = armorBarOutline
        
        -- // armorbar fill
        local armorBarFill = instance_new("Frame")
        armorBarFill.Name = "ArmorBarFill"
        armorBarFill.BackgroundTransparency = 0
        armorBarFill.BorderSizePixel = 0
        armorBarFill.AnchorPoint = vec2(0, 1)
        armorBarFill.Position = dim2(0, 0, 1, 0)
        armorBarFill.Size = dim2(1, 0, 1, 0)
        armorBarFill.Parent = armorBarOutline
        
        local armorBarGradient = instance_new("UIGradient")
        armorBarGradient.Name = "ArmorBarGradient"
        armorBarGradient.Rotation = 90
        armorBarGradient.Color = rgbseq({
            rgbkey(0, rgb(0, 150, 255)),
            rgbkey(0.33, rgb(0, 150, 255)),
            rgbkey(0.66, rgb(0, 150, 255)),
            rgbkey(1, rgb(0, 150, 255))
        })
        armorBarGradient.Parent = armorBarFill
        
        return {
            player = player,
            box = box,
            stroke = stroke,
            gradient = gradient,
            outlineFrame = outlineFrame,
            outlineStroke = outlineStroke,
            inlineFrame = inlineFrame,
            inlineStroke = inlineStroke,
            character = character,
            healthBarOutline = healthBarOutline,
            healthBarOutlineStroke = healthBarOutlineStroke,
            healthBarFill = healthBarFill,
            healthBarGradient = healthBarGradient,
            armorBarOutline = armorBarOutline,
            armorBarOutlineStroke = armorBarOutlineStroke,
            armorBarFill = armorBarFill,
            armorBarGradient = armorBarGradient,
            lastHealth = 1,
            lastArmor = 1
        }
    end
    
    function espFramework:removeBox(player)
        local espData = espCache[player]
        if espData then
            if espData.box then
                espData.box:Destroy()
            end
            if espData.healthBarOutline then
                espData.healthBarOutline:Destroy()
            end
            if espData.armorBarOutline then
                espData.armorBarOutline:Destroy()
            end
        end
        espCache[player] = nil
    end
    
    function espFramework:updateBox(espData, flags)
        if not espData or not espData.character or not espData.box then return end
        
        local character = espData.character
        -- // character validation
        if not character.Parent then
            espData.box.Visible = false
            if espData.healthBarOutline then
                espData.healthBarOutline.Visible = false
            end
            if espData.armorBarOutline then
                espData.armorBarOutline.Visible = false
            end
            return
        end
        
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then
            espData.box.Visible = false
            if espData.healthBarOutline then
                espData.healthBarOutline.Visible = false
            end
            if espData.armorBarOutline then
                espData.armorBarOutline.Visible = false
            end
            return
        end
        
        -- // screen position
        local hrpPosition = hrp.Position
        local boxPos, onScreen = camera:WorldToViewportPoint(hrpPosition)
        
        if not onScreen then
            espData.box.Visible = false
            if espData.healthBarOutline then
                espData.healthBarOutline.Visible = false
            end
            if espData.armorBarOutline then
                espData.armorBarOutline.Visible = false
            end
            return
        end
        
        -- // distance для динамических отступов
        local distance = (hrpPosition - camera.CFrame.Position).Magnitude
        
        -- // box dimensions
        local sizeX = 2.5
        local sizeY = 6
        local sizeZ = 1.5
        
        -- // 8 corners calculation (улучшенный расчет для точного размера)
        local corners = {}
        -- Передние углы (Z = sizeZ/2)
        corners[1] = camera:WorldToViewportPoint((hrp.CFrame * cfr(-sizeX/2, -sizeY/2, sizeZ/2)).Position)
        corners[2] = camera:WorldToViewportPoint((hrp.CFrame * cfr(sizeX/2, -sizeY/2, sizeZ/2)).Position)
        corners[3] = camera:WorldToViewportPoint((hrp.CFrame * cfr(-sizeX/2, sizeY/2, sizeZ/2)).Position)
        corners[4] = camera:WorldToViewportPoint((hrp.CFrame * cfr(sizeX/2, sizeY/2, sizeZ/2)).Position)
        -- Задние углы (Z = -sizeZ/2)
        corners[5] = camera:WorldToViewportPoint((hrp.CFrame * cfr(-sizeX/2, -sizeY/2, -sizeZ/2)).Position)
        corners[6] = camera:WorldToViewportPoint((hrp.CFrame * cfr(sizeX/2, -sizeY/2, -sizeZ/2)).Position)
        corners[7] = camera:WorldToViewportPoint((hrp.CFrame * cfr(-sizeX/2, sizeY/2, -sizeZ/2)).Position)
        corners[8] = camera:WorldToViewportPoint((hrp.CFrame * cfr(sizeX/2, sizeY/2, -sizeZ/2)).Position)
        
        -- // min/max coordinates
        local minX, minY = math.huge, math.huge
        local maxX, maxY = -math.huge, -math.huge
        
        for i = 1, 8 do
            local corner = corners[i]
            minX = min(minX, corner.X)
            minY = min(minY, corner.Y)
            maxX = max(maxX, corner.X)
            maxY = max(maxY, corner.Y)
        end
        
        local boxWidth = maxX - minX
        local boxHeight = maxY - minY
        local boxX = minX
        local boxY = minY
        
        -- // save position for healthbar
        espData.lastBoxX = boxX
        espData.lastBoxY = boxY
        espData.lastBoxWidth = boxWidth
        espData.lastBoxHeight = boxHeight
        
        -- // update box
        local boxEnabled = flags and flags["box_esp_enabled"] or false
        espData.box.Visible = boxEnabled
        if boxEnabled then
            espData.box.Position = dim2(0, boxX, 0, boxY)
            espData.box.Size = dim2(0, boxWidth, 0, boxHeight)
        end
        
        -- // update healthbar
        local healthEnabled = flags and flags["healthbar_enabled"] or false
        if healthEnabled and espData.healthBarFill and espData.healthBarOutline and espData.lastBoxX then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local currentHealth = min(humanoid.Health / humanoid.MaxHealth, 1)
                local lastHealth = espData.lastHealth or currentHealth
                local lerpedHealth = lastHealth + (currentHealth - lastHealth) * 0.05
                espData.lastHealth = lerpedHealth
                
                -- // dynamic offset (используем уже вычисленное distance)
                local baseOffset = 4.1
                local scaleFactor = clamp(1 + (distance / 100) * 0.2, 1, 1.2)
                local dynamicOffset = baseOffset * scaleFactor
                
                -- // bar width
                local barWidth = 0.6
                
                -- // healthbar position (слева от бокса)
                local barX = espData.lastBoxX - dynamicOffset - barWidth - 1
                local barY = espData.lastBoxY - 1
                local barHeight = espData.lastBoxHeight + 2
                
                espData.healthBarOutline.Position = dim2(0, barX, 0, barY)
                espData.healthBarOutline.Size = dim2(0, barWidth + 2, 0, barHeight)
                espData.healthBarOutline.Visible = true
                
                -- // healthbar fill
                espData.healthBarFill.Size = dim2(1, 0, lerpedHealth, 0)
            else
                espData.healthBarOutline.Visible = false
            end
        else
            if espData.healthBarOutline then
                espData.healthBarOutline.Visible = false
            end
        end
        
        -- // update armorbar
        local armorEnabled = flags and flags["armorbar_enabled"] or false
        if armorEnabled and espData.armorBarFill and espData.armorBarOutline and espData.lastBoxX then
            -- // get armor value from workspace.Players.[PlayerName].BodyEffects.Armor
            local armorValue = 0
            local workspacePlayers = ws:FindFirstChild("Players")
            if workspacePlayers then
                local playerFolder = workspacePlayers:FindFirstChild(espData.player.Name)
                if playerFolder then
                    local bodyEffects = playerFolder:FindFirstChild("BodyEffects")
                    if bodyEffects then
                        local armorIntValue = bodyEffects:FindFirstChild("Armor")
                        if armorIntValue and armorIntValue:IsA("IntValue") then
                            armorValue = armorIntValue.Value
                        end
                    end
                end
            end
            
            local currentArmor = min(armorValue / 130, 1)
            local lastArmor = espData.lastArmor or currentArmor
            local lerpedArmor = lastArmor + (currentArmor - lastArmor) * 0.05
            espData.lastArmor = lerpedArmor
            
            -- // dynamic offset (используем уже вычисленное distance)
            local baseOffset = 4.1
            local scaleFactor = clamp(1 + (distance / 100) * 0.2, 1, 1.2)
            local dynamicOffset = baseOffset * scaleFactor
            
            -- // bar width
            local barWidth = 0.6
            
            -- // armorbar position (справа от бокса)
            local barX = espData.lastBoxX + espData.lastBoxWidth + dynamicOffset
            local barY = espData.lastBoxY - 1
            local barHeight = espData.lastBoxHeight + 2
            
            espData.armorBarOutline.Position = dim2(0, barX, 0, barY)
            espData.armorBarOutline.Size = dim2(0, barWidth + 2, 0, barHeight)
            espData.armorBarOutline.Visible = true
            
            -- // armorbar fill
            espData.armorBarFill.Size = dim2(1, 0, lerpedArmor, 0)
        else
            if espData.armorBarOutline then
                espData.armorBarOutline.Visible = false
            end
        end
    end
    
    function espFramework:getESP(player)
        return espCache[player]
    end
    
    function espFramework:setESP(player, espData)
        espCache[player] = espData
    end
    
    function espFramework:clearAll()
        for player, espData in pairs(espCache) do
            if espData.box then
                espData.box:Destroy()
            end
            if espData.healthBarOutline then
                espData.healthBarOutline:Destroy()
            end
            if espData.armorBarOutline then
                espData.armorBarOutline:Destroy()
            end
        end
        espCache = {}
    end
    
    function espFramework:updateAllBoxes(flags)
        for player, espData in pairs(espCache) do
            espFramework:updateBox(espData, flags)
        end
    end
    
    function espFramework:applySettings(espData, flags)
        if not espData then return end
        
        -- // gradient colors
        if espData.gradient then
            local c1 = flags["box_color_1"] and flags["box_color_1"].Color or rgb(255, 255, 255)
            local c2 = flags["box_color_2"] and flags["box_color_2"].Color or rgb(255, 255, 255)
            local c3 = flags["box_color_3"] and flags["box_color_3"].Color or rgb(255, 255, 255)
            local c4 = flags["box_color_4"] and flags["box_color_4"].Color or rgb(255, 255, 255)
            espData.gradient.Color = rgbseq({
                rgbkey(0, c1),
                rgbkey(0.33, c2),
                rgbkey(0.66, c3),
                rgbkey(1, c4)
            })
            if flags["box_gradient_rotation"] then
                espData.gradient.Rotation = flags["box_gradient_rotation"]
            end
        end
        
        -- // outline settings - всегда включен
        espData.outlineStroke.Color = rgb(0, 0, 0)
        espData.inlineStroke.Color = rgb(0, 0, 0)
        espData.outlineFrame.Visible = true
        espData.inlineFrame.Visible = true
        
        -- // healthbar gradient colors
        if espData.healthBarGradient then
            local h1 = flags["healthbar_color_1"] and flags["healthbar_color_1"].Color or rgb(0, 255, 0)
            local h2 = flags["healthbar_color_2"] and flags["healthbar_color_2"].Color or rgb(0, 255, 0)
            local h3 = flags["healthbar_color_3"] and flags["healthbar_color_3"].Color or rgb(0, 255, 0)
            local h4 = flags["healthbar_color_4"] and flags["healthbar_color_4"].Color or rgb(0, 255, 0)
            espData.healthBarGradient.Color = rgbseq({
                rgbkey(0, h1),
                rgbkey(0.33, h2),
                rgbkey(0.66, h3),
                rgbkey(1, h4)
            })
            if flags["healthbar_gradient_rotation"] then
                espData.healthBarGradient.Rotation = flags["healthbar_gradient_rotation"]
            end
        end
        
        -- // armorbar gradient colors
        if espData.armorBarGradient then
            local a1 = flags["armorbar_color_1"] and flags["armorbar_color_1"].Color or rgb(0, 150, 255)
            local a2 = flags["armorbar_color_2"] and flags["armorbar_color_2"].Color or rgb(0, 150, 255)
            local a3 = flags["armorbar_color_3"] and flags["armorbar_color_3"].Color or rgb(0, 150, 255)
            local a4 = flags["armorbar_color_4"] and flags["armorbar_color_4"].Color or rgb(0, 150, 255)
            espData.armorBarGradient.Color = rgbseq({
                rgbkey(0, a1),
                rgbkey(0.33, a2),
                rgbkey(0.66, a3),
                rgbkey(1, a4)
            })
            if flags["armorbar_gradient_rotation"] then
                espData.armorBarGradient.Rotation = flags["armorbar_gradient_rotation"]
            end
        end
    end
    
    function espFramework:startESP()
        if espConnection then return end
        
        -- RenderStepped обновление для плавности
        espConnection = run.RenderStepped:Connect(function()
            espFramework:updateAllBoxes(library.flags)
        end)
    end
    
    function espFramework:stopESP()
        if espConnection then
            espConnection:Disconnect()
            espConnection = nil
        end
        espFramework:clearAll()
    end
    
    function espFramework:shouldESPRun()
        local flags = library.flags
        return (flags and flags["box_esp_enabled"]) or 
               (flags and flags["healthbar_enabled"]) or 
               (flags and flags["armorbar_enabled"])
    end
    
    function espFramework:checkESPState()
        if espFramework:shouldESPRun() then
            espFramework:startESP()
        else
            espFramework:stopESP()
        end
    end
    
    -- // Highlight Chams Functions
    function espFramework:createHighlight(player)
        if not player or not player.Character then return end
        
        local character = player.Character
        local existingHighlight = character:FindFirstChild("ESPHighlight")
        
        -- Если highlight уже существует и настройки не изменились, не пересоздаем
        if existingHighlight then
            local currentFillColor = library.flags["highlight_fill_color"] and library.flags["highlight_fill_color"].Color or rgb(255, 0, 0)
            local currentOutlineColor = library.flags["highlight_outline_color"] and library.flags["highlight_outline_color"].Color or rgb(255, 255, 255)
            local currentFillTransparency = library.flags["highlight_fill_transparency"] or 0.5
            local currentOutlineTransparency = library.flags["highlight_outline_transparency"] or 0
            
            -- Обновляем настройки существующего highlight
            existingHighlight.FillColor = currentFillColor
            existingHighlight.OutlineColor = currentOutlineColor
            existingHighlight.FillTransparency = currentFillTransparency
            existingHighlight.OutlineTransparency = currentOutlineTransparency
            return existingHighlight
        end
        
        local highlight = instance_new("Highlight")
        highlight.Name = "ESPHighlight"
        highlight.Adornee = character
        highlight.FillColor = library.flags["highlight_fill_color"] and library.flags["highlight_fill_color"].Color or rgb(255, 0, 0)
        highlight.OutlineColor = library.flags["highlight_outline_color"] and library.flags["highlight_outline_color"].Color or rgb(255, 255, 255)
        highlight.FillTransparency = library.flags["highlight_fill_transparency"] or 0.5
        highlight.OutlineTransparency = library.flags["highlight_outline_transparency"] or 0
        highlight.Parent = character
        
        return highlight
    end
    
    function espFramework:removeHighlight(player)
        if not player or not player.Character then return end
        
        local character = player.Character
        local highlight = character:FindFirstChild("ESPHighlight")
        
        if highlight then
            highlight:Destroy()
        end
    end
    
    function espFramework:updateAllHighlights(flags)
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= lp and player.Character then
                local character = player.Character
                local highlight = character:FindFirstChild("ESPHighlight")
                
                if highlight then
                    highlight.FillColor = flags["highlight_fill_color"] and flags["highlight_fill_color"].Color or rgb(255, 0, 0)
                    highlight.OutlineColor = flags["highlight_outline_color"] and flags["highlight_outline_color"].Color or rgb(255, 255, 255)
                    highlight.FillTransparency = flags["highlight_fill_transparency"] or 0.5
                    highlight.OutlineTransparency = flags["highlight_outline_transparency"] or 0
                end
            end
        end
    end
    
    function espFramework:clearAllHighlights()
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= lp then
                espFramework:removeHighlight(player)
            end
        end
    end
    
    -- // Material Chams Functions (оптимизированные)
    local originalColors = {} -- Хранилище оригинальных цветов
    local originalClothing = {} -- Хранилище оригинальной одежды
    
    function espFramework:setPlayerMaterial(player, materialName)
        if not player or not player.Character then return end
        
        local character = player.Character
        local materialColor = library.flags["material_chams_color"] and library.flags["material_chams_color"].Color or rgb(255, 255, 255)
        
        -- Обрабатываем только основные части тела (оптимизация FPS)
        local bodyParts = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg", 
                          "UpperTorso", "LowerTorso", "LeftUpperArm", "RightUpperArm", 
                          "LeftLowerArm", "RightLowerArm", "LeftUpperLeg", "RightUpperLeg", 
                          "LeftLowerLeg", "RightLowerLeg", "LeftHand", "RightHand", "LeftFoot", "RightFoot"}
        
        for _, partName in ipairs(bodyParts) do
            local part = character:FindFirstChild(partName)
            if part and part:IsA("BasePart") then
                local partKey = player.Name .. "_" .. partName
                
                if materialName == "Neon" then
                    -- Сохраняем оригинальный цвет перед изменением
                    if not originalColors[partKey] then
                        originalColors[partKey] = part.Color
                    end
                    
                    part.Material = Enum.Material.Neon
                    part.Color = materialColor
                    -- Убираем текстуры для MeshPart
                    if part:IsA("MeshPart") then
                        part.TextureID = ""
                    end
                else
                    -- Восстанавливаем оригинальный цвет
                    part.Material = Enum.Material.Plastic
                    if originalColors[partKey] then
                        part.Color = originalColors[partKey]
                    end
                end
            end
        end
        
        -- Обрабатываем лицо отдельно
        local head = character:FindFirstChild("Head")
        if head then
            local face = head:FindFirstChild("face")
            if face and face:IsA("Decal") and face.Name == "face" then
                if materialName == "Neon" then
                    face.Transparency = 1
                else
                    face.Transparency = 0
                end
            end
            
            -- Убираем текстуры с головы
            for _, mesh in ipairs(head:GetChildren()) do
                if mesh:IsA("SpecialMesh") then
                    if materialName == "Neon" then
                        mesh.TextureId = ""
                    end
                end
            end
        end
        
        -- Управляем одеждой
        local playerKey = player.Name
        if materialName == "Neon" then
            -- Сохраняем одежду перед удалением
            if not originalClothing[playerKey] then
                originalClothing[playerKey] = {}
            end
            
            for _, className in ipairs({"Pants", "Shirt", "ShirtGraphic"}) do
                local clothing = character:FindFirstChildOfClass(className)
                if clothing then
                    -- Сохраняем данные одежды
                    originalClothing[playerKey][className] = {
                        Name = clothing.Name,
                        Properties = {}
                    }
                    
                    -- Сохраняем все свойства одежды
                    if className == "Pants" then
                        originalClothing[playerKey][className].Properties.PantsTemplate = clothing.PantsTemplate
                    elseif className == "Shirt" then
                        originalClothing[playerKey][className].Properties.ShirtTemplate = clothing.ShirtTemplate
                    elseif className == "ShirtGraphic" then
                        originalClothing[playerKey][className].Properties.Graphic = clothing.Graphic
                    end
                    
                    clothing:Destroy()
                end
            end
        else
            -- Восстанавливаем одежду
            if originalClothing[playerKey] then
                for className, clothingData in pairs(originalClothing[playerKey]) do
                    -- Проверяем что одежды еще нет
                    if not character:FindFirstChildOfClass(className) then
                        local newClothing = instance_new(className)
                        newClothing.Name = clothingData.Name
                        
                        -- Восстанавливаем свойства
                        for property, value in pairs(clothingData.Properties) do
                            newClothing[property] = value
                        end
                        
                        newClothing.Parent = character
                    end
                end
            end
        end
    end
    
    function espFramework:setAllPlayersMaterial(materialName)
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= lp then
                espFramework:setPlayerMaterial(player, materialName)
            end
        end
    end
    
    function espFramework:restoreAllPlayersMaterial()
        -- Однократное восстановление материалов без дальнейших проверок
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= lp and player.Character then
                local character = player.Character
                
                -- Восстанавливаем только основные части тела на Plastic
                local bodyParts = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg", 
                                  "UpperTorso", "LowerTorso", "LeftUpperArm", "RightUpperArm", 
                                  "LeftLowerArm", "RightLowerArm", "LeftUpperLeg", "RightUpperLeg", 
                                  "LeftLowerLeg", "RightLowerLeg", "LeftHand", "RightHand", "LeftFoot", "RightFoot"}
                
                for _, partName in ipairs(bodyParts) do
                    local part = character:FindFirstChild(partName)
                    if part and part:IsA("BasePart") then
                        part.Material = Enum.Material.Plastic
                        -- Не трогаем цвет - оставляем как есть
                    end
                end
                
                -- Восстанавливаем лицо
                local head = character:FindFirstChild("Head")
                if head then
                    local face = head:FindFirstChild("face")
                    if face and face:IsA("Decal") then
                        face.Transparency = 0
                    end
                end
            end
        end
    end
    
    function espFramework:updateAllMaterialColors(flags)
        if not flags["material_chams_enabled"] then return end
        
        local materialColor = flags["material_chams_color"] and flags["material_chams_color"].Color or rgb(255, 255, 255)
        
        -- Обрабатываем только основные части тела (оптимизация FPS)
        local bodyParts = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg", 
                          "UpperTorso", "LowerTorso", "LeftUpperArm", "RightUpperArm", 
                          "LeftLowerArm", "RightLowerArm", "LeftUpperLeg", "RightUpperLeg", 
                          "LeftLowerLeg", "RightLowerLeg", "LeftHand", "RightHand", "LeftFoot", "RightFoot"}
        
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= lp and player.Character then
                local character = player.Character
                for _, partName in ipairs(bodyParts) do
                    local part = character:FindFirstChild(partName)
                    if part and part:IsA("BasePart") and part.Material == Enum.Material.Neon then
                        part.Color = materialColor
                    end
                end
            end
        end
    end
    
    function espFramework:clearAllMaterialColors()
        -- Очищаем все сохраненные цвета (для отладки)
        originalColors = {}
    end
    
    function espFramework:clearAllMaterialData()
        -- Очищаем все сохраненные данные материалов и одежды
        originalColors = {}
        originalClothing = {}
    end
    
    -- // Player Events для Highlight, Material Chams и ESP
    players.PlayerAdded:Connect(function(player)
        if player ~= lp then
            player.CharacterAdded:Connect(function(character)
                task_wait(1) -- Ждем полной загрузки персонажа
                if library.flags["highlight_chams_enabled"] then
                    espFramework:createHighlight(player)
                end
                if library.flags["material_chams_enabled"] then
                    espFramework:setPlayerMaterial(player, "Neon")
                end
                -- Добавляем ESP для нового игрока если ESP включен
                if espFramework:shouldESPRun() then
                    local espData = espFramework:getESP(player)
                    if not espData then
                        espData = espFramework:createBox(player)
                        if espData then
                            espFramework:setESP(player, espData)
                            espFramework:applySettings(espData, library.flags)
                        end
                    end
                end
            end)
        end
    end)
    
    players.PlayerRemoving:Connect(function(player)
        if player ~= lp then
            espFramework:removeHighlight(player)
            -- Удаляем ESP данные игрока
            espFramework:removeBox(player)
            -- Очищаем сохраненные цвета и одежду игрока
            for key, _ in pairs(originalColors) do
                if key:find(player.Name .. "_") == 1 then
                    originalColors[key] = nil
                end
            end
            
            -- Очищаем сохраненную одежду
            if originalClothing[player.Name] then
                originalClothing[player.Name] = nil
            end
        end
    end)
    
    -- Обработка уже существующих игроков
    for _, player in ipairs(players:GetPlayers()) do
        if player ~= lp then
            -- Подключаем событие CharacterAdded для будущих респавнов
            player.CharacterAdded:Connect(function(character)
                task_wait(1) -- Ждем полной загрузки персонажа
                if library.flags["highlight_chams_enabled"] then
                    espFramework:createHighlight(player)
                end
                if library.flags["material_chams_enabled"] then
                    espFramework:setPlayerMaterial(player, "Neon")
                end
                -- Добавляем ESP для нового персонажа если ESP включен
                if espFramework:shouldESPRun() then
                    local espData = espFramework:getESP(player)
                    if not espData then
                        espData = espFramework:createBox(player)
                        if espData then
                            espFramework:setESP(player, espData)
                            espFramework:applySettings(espData, library.flags)
                        end
                    end
                end
            end)
            
            -- Обрабатываем уже существующих персонажей
            if player.Character then
                task_spawn(function()
                    task_wait(1) -- Ждем полной загрузки персонажа
                    if library.flags["highlight_chams_enabled"] then
                        espFramework:createHighlight(player)
                    end
                    if library.flags["material_chams_enabled"] then
                        espFramework:setPlayerMaterial(player, "Neon")
                    end
                    -- Добавляем ESP для существующего персонажа если ESP включен
                    if espFramework:shouldESPRun() then
                        local espData = espFramework:getESP(player)
                        if not espData then
                            espData = espFramework:createBox(player)
                            if espData then
                                espFramework:setESP(player, espData)
                                espFramework:applySettings(espData, library.flags)
                            end
                        end
                    end
                end)
            end
        end
    end
    
    _G.espFramework = espFramework
end

-- // SelfMaterial Module
do
    local selfMaterialSettings = {
        enabled = false,
        material = "ForceField",
        color = rgb(255, 0, 0)
    }
    
    local originalCharacterColors = {}
    local selfMaterialConnection = nil
    
    local function StartSelfMaterial()
        if selfMaterialConnection then
            selfMaterialConnection:Disconnect()
            selfMaterialConnection = nil
        end
        
        selfMaterialConnection = run.Heartbeat:Connect(function()
            if selfMaterialSettings.enabled and lp.Character then
                local character = lp.Character
                
                for _, part in ipairs(character:GetChildren()) do
                    if part:IsA("BasePart") then
                        if not originalCharacterColors[part] then
                            originalCharacterColors[part] = part.Color
                        end
                        
                        part.Material = enum.Material[selfMaterialSettings.material]
                        part.Color = selfMaterialSettings.color
                    end
                end
            end
        end)
    end
    
    local function StopSelfMaterial()
        if selfMaterialConnection then
            selfMaterialConnection:Disconnect()
            selfMaterialConnection = nil
        end
        
        -- Восстанавливаем оригинальные цвета
        if lp.Character then
            for part, originalColor in pairs(originalCharacterColors) do
                if part and part.Parent then
                    part.Color = originalColor
                    part.Material = enum.Material.Plastic -- Возвращаем стандартный материал
                end
            end
        end
        originalCharacterColors = {}
    end
    
    _G.selfMaterialSettings = selfMaterialSettings
    _G.StartSelfMaterial = StartSelfMaterial
    _G.StopSelfMaterial = StopSelfMaterial
end

-- // SelfHighlight Module
do
    local selfHighlightSettings = {
        enabled = false,
        fillColor = rgb(255, 0, 0),
        outlineColor = rgb(255, 255, 255),
        fillTransparency = 0.5,
        outlineTransparency = 0
    }
    
    local selfHighlight = nil
    
    local function StartSelfHighlight()
        if selfHighlight then
            selfHighlight:Destroy()
            selfHighlight = nil
        end
        
        if lp.Character then
            selfHighlight = instance_new("Highlight")
            selfHighlight.Name = "SelfHighlight"
            selfHighlight.Adornee = lp.Character
            selfHighlight.FillColor = selfHighlightSettings.fillColor
            selfHighlight.OutlineColor = selfHighlightSettings.outlineColor
            selfHighlight.FillTransparency = selfHighlightSettings.fillTransparency
            selfHighlight.OutlineTransparency = selfHighlightSettings.outlineTransparency
            selfHighlight.Parent = lp.Character
        end
    end
    
    local function StopSelfHighlight()
        if selfHighlight then
            selfHighlight:Destroy()
            selfHighlight = nil
        end
    end
    
    local function UpdateSelfHighlight()
        if selfHighlight and selfHighlightSettings.enabled then
            selfHighlight.FillColor = selfHighlightSettings.fillColor
            selfHighlight.OutlineColor = selfHighlightSettings.outlineColor
            selfHighlight.FillTransparency = selfHighlightSettings.fillTransparency
            selfHighlight.OutlineTransparency = selfHighlightSettings.outlineTransparency
        end
    end
    
    -- Обработка респавна персонажа
    lp.CharacterAdded:Connect(function(character)
        if selfHighlightSettings.enabled then
            task_wait(0.1) -- Ждем загрузки персонажа
            StartSelfHighlight()
        end
    end)
    
    _G.selfHighlightSettings = selfHighlightSettings
    _G.StartSelfHighlight = StartSelfHighlight
    _G.StopSelfHighlight = StopSelfHighlight
    _G.UpdateSelfHighlight = UpdateSelfHighlight
end

-- // GunMaterial Module
do
    local gunMaterialSettings = {
        enabled = false,
        material = "ForceField",
        color = rgb(255, 0, 0)
    }
    
    local originalGunColors = {}
    local gunMaterialConnection = nil
    
    local function ApplyGunMaterial()
        if lp.Character then
            for _, tool in ipairs(lp.Character:GetChildren()) do
                if tool:IsA("Tool") then
                    for _, part in ipairs(tool:GetDescendants()) do
                        if part:IsA("BasePart") then
                            -- Сохраняем оригинальный цвет при первом применении
                            if not originalGunColors[part] then
                                originalGunColors[part] = part.Color
                            end
                            
                            part.Material = enum.Material[gunMaterialSettings.material]
                            part.Color = gunMaterialSettings.color
                        end
                    end
                end
            end
        end
    end
    
    local function StartGunMaterial()
        if gunMaterialConnection then
            gunMaterialConnection:Disconnect()
            gunMaterialConnection = nil
        end
        
        gunMaterialConnection = run.Heartbeat:Connect(function()
            if gunMaterialSettings.enabled then
                ApplyGunMaterial()
            end
        end)
    end
    
    local function StopGunMaterial()
        if gunMaterialConnection then
            gunMaterialConnection:Disconnect()
            gunMaterialConnection = nil
        end
        
        -- Восстанавливаем оригинальные цвета и материалы
        if lp.Character then
            for _, tool in ipairs(lp.Character:GetChildren()) do
                if tool:IsA("Tool") then
                    for _, part in ipairs(tool:GetDescendants()) do
                        if part:IsA("BasePart") and originalGunColors[part] then
                            part.Color = originalGunColors[part]
                            part.Material = enum.Material.Plastic -- Возвращаем стандартный материал
                        end
                    end
                end
            end
        end
        originalGunColors = {}
    end
    
    _G.gunMaterialSettings = gunMaterialSettings
    _G.StartGunMaterial = StartGunMaterial
    _G.StopGunMaterial = StopGunMaterial
    _G.ApplyGunMaterial = ApplyGunMaterial
end

-- // GunHighlight Module
do
    local gunHighlightSettings = {
        enabled = false,
        fillColor = rgb(255, 0, 0),
        outlineColor = rgb(255, 255, 255),
        fillTransparency = 0.5,
        outlineTransparency = 0
    }
    
    local gunHighlights = {}
    local gunHighlightConnection = nil
    
    local function ApplyGunHighlight()
        if lp.Character then
            for _, tool in ipairs(lp.Character:GetChildren()) do
                if tool:IsA("Tool") then
                    -- Удаляем старый highlight если есть
                    local existingHighlight = tool:FindFirstChild("GunHighlight")
                    if existingHighlight then
                        existingHighlight:Destroy()
                    end
                    
                    -- Создаем новый highlight
                    local highlight = instance_new("Highlight")
                    highlight.Name = "GunHighlight"
                    highlight.Adornee = tool
                    highlight.FillColor = gunHighlightSettings.fillColor
                    highlight.OutlineColor = gunHighlightSettings.outlineColor
                    highlight.FillTransparency = gunHighlightSettings.fillTransparency
                    highlight.OutlineTransparency = gunHighlightSettings.outlineTransparency
                    highlight.Parent = tool
                    
                    gunHighlights[tool] = highlight
                end
            end
        end
    end
    
    local function StartGunHighlight()
        if gunHighlightConnection then
            gunHighlightConnection:Disconnect()
            gunHighlightConnection = nil
        end
        
        gunHighlightConnection = run.Heartbeat:Connect(function()
            if gunHighlightSettings.enabled then
                ApplyGunHighlight()
            end
        end)
    end
    
    local function StopGunHighlight()
        if gunHighlightConnection then
            gunHighlightConnection:Disconnect()
            gunHighlightConnection = nil
        end
        
        -- Удаляем все highlights с оружия
        if lp.Character then
            for _, tool in ipairs(lp.Character:GetChildren()) do
                if tool:IsA("Tool") then
                    local highlight = tool:FindFirstChild("GunHighlight")
                    if highlight then
                        highlight:Destroy()
                    end
                end
            end
        end
        gunHighlights = {}
    end
    
    local function UpdateGunHighlight()
        if gunHighlightSettings.enabled then
            for tool, highlight in pairs(gunHighlights) do
                if highlight and highlight.Parent then
                    highlight.FillColor = gunHighlightSettings.fillColor
                    highlight.OutlineColor = gunHighlightSettings.outlineColor
                    highlight.FillTransparency = gunHighlightSettings.fillTransparency
                    highlight.OutlineTransparency = gunHighlightSettings.outlineTransparency
                end
            end
        end
    end
    
    _G.gunHighlightSettings = gunHighlightSettings
    _G.StartGunHighlight = StartGunHighlight
    _G.StopGunHighlight = StopGunHighlight
    _G.UpdateGunHighlight = UpdateGunHighlight
end

-- // Window
local window = library:window({
    name = "R4ZE", 
    suffix = ".PUB", 
    gameInfo = "Raze.pub v3"
})

-- // Combat Tab
do
    local CameraBotTab, SilentBotTab, OtherTab = window:tab({
        name = "Combat", 
        icon = "rbxassetid://10734975692",  -- lucide-target
        tabs = {"CameraBot", "SilentBot", "Other"}
    })
    
    -- CameraBot Section
    do
        local CameraBotSection = CameraBotTab:column({})
        local section = CameraBotSection:section({name = "CameraBot", default = false})
        
        -- Camera Aimbot Implementation
        do
            -- Camera Aimbot Variables
            local cameraSettings = {
                enabled = false,
                stickyTarget = nil,
                stickyEnabled = false,
                targetPart = "Head",
                aimlockType = "Mouse Movement",
                -- Prediction settings
                predictionEnabled = false,
                customPredictionX = 0.021111111,
                customPredictionY = 0.0102,
                -- Resolver settings
                resolverEnabled = false,
                resolverMode = "Velocity",
                -- Checks settings
                checksEnabled = false,
                checkKO = false,
                checkGrabbed = false,
                checkForceField = false,
                checkWall = false
            }
            
            -- Helper Functions
            local function MouseMover(X, Y)
                mousemoverel(X, Y)    
            end
            
            local function getCameraTarget()
                if cameraSettings.stickyEnabled then
                    if cameraSettings.stickyTarget and cameraSettings.stickyTarget.Parent then
                        return cameraSettings.stickyTarget
                    else
                        -- Захватываем новую цель если sticky включен
                        local checks = cameraSettings.checksEnabled and {
                            checkKO = cameraSettings.checkKO,
                            checkGrabbed = cameraSettings.checkGrabbed,
                            checkForceField = cameraSettings.checkForceField,
                            checkWall = cameraSettings.checkWall
                        } or nil
                        local predX = cameraSettings.predictionEnabled and cameraSettings.customPredictionX or 0
                        local predY = cameraSettings.predictionEnabled and cameraSettings.customPredictionY or 0
                        cameraSettings.stickyTarget = _G.silentUtility:getClosestPlayer(math.huge, cameraSettings.targetPart, false, checks, predX, predY)
                        return cameraSettings.stickyTarget
                    end
                else
                    cameraSettings.stickyTarget = nil
                    return nil
                end
            end
            
            -- Main Camera Aimbot Toggle
            local mainToggle = section:toggle({
                name = "Camera Aimbot", 
                flag = "camera_enabled",
                type = "toggle",
                callback = function(bool)
                    cameraSettings.enabled = bool
                    if not bool then
                        cameraSettings.stickyTarget = nil
                    end
                end,
                seperator = true
            })
            
            -- Sticky Target Keybind  
            section:keybind({
                name = "Sticky Target",
                flag = "camera_sticky_key", 
                key = enum.KeyCode.T,
                mode = "Toggle",
                default = false,
                callback = function(active)
                    cameraSettings.stickyEnabled = active
                end,
                seperator = true
            })
            
            -- Aimlock Type Dropdown
            section:dropdown({
                name = "Aimlock Type",
                flag = "camera_aimlock_type",
                items = {
                    "Mouse Movement",
                    "MoveCenterOfScreen"
                },
                default = "Mouse Movement",
                callback = function(selected)
                    cameraSettings.aimlockType = selected
                end,
                seperator = true
            })
            
            -- Prediction Toggle
            local predictionToggle = section:toggle({
                name = "Prediction", 
                flag = "camera_prediction_enabled",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.predictionEnabled = bool
                end,
                seperator = true
            })
            
            -- Prediction Settings Sub-section
            local predictionSubSection = predictionToggle:settings({})
            
            -- Prediction X Textbox
            predictionSubSection:textbox({
                name = "Prediction X",
                flag = "camera_prediction_x",
                placeholder = "0.021111111",
                callback = function(text)
                    local value = tonumber(text)
                    if value then
                        cameraSettings.customPredictionX = value
                    end
                end,
                seperator = true
            })
            
            -- Prediction Y Textbox
            predictionSubSection:textbox({
                name = "Prediction Y",
                flag = "camera_prediction_y",
                placeholder = "0.0102",
                callback = function(text)
                    local value = tonumber(text)
                    if value then
                        cameraSettings.customPredictionY = value
                    end
                end,
                seperator = true
            })
            
            -- Resolver Toggle
            local resolverToggle = section:toggle({
                name = "Resolver", 
                flag = "camera_resolver_enabled",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.resolverEnabled = bool
                end,
                seperator = true
            })
            
            -- Resolver Settings Sub-section
            local resolverSubSection = resolverToggle:settings({})
            
            -- Resolver Mode Dropdown
            resolverSubSection:dropdown({
                name = "Resolver Mode",
                flag = "camera_resolver_mode",
                items = {
                    "Velocity",
                    "MoveDirection", 
                    "CalculateCFrame"
                },
                default = "Velocity",
                callback = function(selected)
                    cameraSettings.resolverMode = selected
                end,
                seperator = true
            })
            
            -- Hitparts Dropdown
            section:dropdown({
                name = "Hitparts",
                flag = "camera_hitparts",
                items = {
                    "Head",
                    "UpperTorso", 
                    "LowerTorso",
                    "LeftUpperArm",
                    "LeftLowerArm",
                    "LeftHand",
                    "RightUpperArm",
                    "RightLowerArm", 
                    "RightHand",
                    "LeftUpperLeg",
                    "LeftLowerLeg",
                    "LeftFoot",
                    "RightUpperLeg",
                    "RightLowerLeg",
                    "RightFoot"
                },
                default = "Head",
                callback = function(selected)
                    cameraSettings.targetPart = selected
                end,
                seperator = true
            })
            
            -- Checks Toggle
            local checksToggle = section:toggle({
                name = "Checks", 
                flag = "camera_checks_enabled",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checksEnabled = bool
                end,
                seperator = true
            })
            
            -- Checks Settings Sub-section
            local checksSubSection = checksToggle:settings({})
            
            -- KO Check
            checksSubSection:toggle({
                name = "Check K.O",
                flag = "camera_check_ko",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checkKO = bool
                end,
                seperator = true
            })
            
            -- Grabbed Check
            checksSubSection:toggle({
                name = "Check Grabbed",
                flag = "camera_check_grabbed",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checkGrabbed = bool
                end,
                seperator = true
            })
            
            -- ForceField Check
            checksSubSection:toggle({
                name = "Check ForceField",
                flag = "camera_check_forcefield",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checkForceField = bool
                end,
                seperator = true
            })
            
            -- Wall Check
            checksSubSection:toggle({
                name = "Check Wall",
                flag = "camera_check_wall",
                type = "checkbox",
                callback = function(bool)
                    cameraSettings.checkWall = bool
                end,
                seperator = true
            })
            
            -- Camera Aimbot Loop
            run.RenderStepped:Connect(function()
                if not cameraSettings.enabled then
                    return
                end
                
                local target = getCameraTarget()
                if target then
                    -- Используем prediction если включен
                    local targetPosition = target.Position
                    if cameraSettings.predictionEnabled then
                        local predX = cameraSettings.customPredictionX
                        local predY = cameraSettings.customPredictionY
                        targetPosition = _G.silentUtility:predict(target, predX, predY) or target.Position
                    end
                    
                    local screenPos, onScreen = camera:WorldToViewportPoint(targetPosition)
                    
                    if onScreen then
                        if cameraSettings.aimlockType == "Mouse Movement" then
                            local mousePos = uis:GetMouseLocation()
                            local deltaX = screenPos.X - mousePos.X
                            local deltaY = screenPos.Y - mousePos.Y
                            
                            -- Перемещаем курсор к цели
                            MouseMover(deltaX, deltaY)
                            
                        elseif cameraSettings.aimlockType == "MoveCenterOfScreen" then
                            local screenSize = camera.ViewportSize
                            local centerX = screenSize.X / 2
                            local centerY = screenSize.Y / 2
                            
                            local deltaX = screenPos.X - centerX
                            local deltaY = screenPos.Y - centerY
                            
                            -- Двигаем камеру чтобы цель была в центре экрана
                            local currentCFrame = camera.CFrame
                            local lookDirection = (targetPosition - currentCFrame.Position).Unit
                            camera.CFrame = cfr(currentCFrame.Position, currentCFrame.Position + lookDirection)
                        end
                    end
                end
            end)
            
        end
    end
    
    -- SilentBot Section  
    do
        local SilentBotSection = SilentBotTab:column({})
        local section = SilentBotSection:section({name = "SilentBot", default = false})
        
        -- Silent Aimbot Implementation
        do
            -- Silent Aimbot Variables
            local silentSettings = {
                enabled = false,
                stickyTarget = nil,
                fovRadius = 350,
                targetPart = "Head",
                useFov = true,
                showFov = true,
                fovColor = rgb(0, 169, 255),
                fovTransparency = 0.5,
                predictionX = 0.021111111,
                predictionY = 0.0102,
                stickyKey = enum.KeyCode.C,
                -- Visualise settings
                visualiseEnabled = false,
                highlightEnabled = false,
                highlightFillColor = rgb(0, 169, 255),
                highlightFillTransparency = 0.5,
                highlightOutlineColor = rgb(0, 169, 255),
                highlightOutlineTransparency = 0.5,
                tracerEnabled = false,
                tracerColor = rgb(0, 169, 255),
                tracerTransparency = 0.5,
                -- Checks settings
                checksEnabled = false,
                checkKO = false,
                checkGrabbed = false,
                checkForceField = false,
                checkWall = false,
                -- Prediction settings
                predictionEnabled = false,
                customPredictionX = 0.021111111,
                customPredictionY = 0.0102,
                -- Resolver settings
                resolverEnabled = false,
                resolverMode = "Velocity",
                -- Sticky settings
                stickyEnabled = false
            }
            
            -- ScreenGui FOV Circle
            local screenGui = instance_new("ScreenGui")
            screenGui.Name = "SilentAimbotFOV"
            screenGui.Parent = coregui
            
            local fovFrame = instance_new("Frame")
            fovFrame.Name = "FOVCircle"
            fovFrame.BackgroundTransparency = 1
            fovFrame.BorderSizePixel = 0
            fovFrame.Size = udim2_offset(silentSettings.fovRadius * 2, silentSettings.fovRadius * 2)
            fovFrame.Position = udim2_offset(0, 0)
            fovFrame.AnchorPoint = vec2(0.5, 0.5)
            fovFrame.Visible = false
            fovFrame.Parent = screenGui
            
            local fovCircle = instance_new("UIStroke")
            fovCircle.Thickness = 2
            fovCircle.Color = silentSettings.fovColor
            fovCircle.Transparency = silentSettings.fovTransparency
            fovCircle.Parent = fovFrame
            
            local fovCorner = instance_new("UICorner")
            fovCorner.CornerRadius = dim(0.5, 0)
            fovCorner.Parent = fovFrame
            
            local esp = nil
            local tracerLine = drawing_new("Line")
            tracerLine.Thickness = 2
            tracerLine.Color = silentSettings.tracerColor
            tracerLine.Transparency = silentSettings.tracerTransparency
            tracerLine.Visible = false
            
            -- Helper Functions
            local function highlightPlayer(target)
                if not silentSettings.visualiseEnabled or not silentSettings.highlightEnabled then
                    return
                end
                
                if esp then esp:Destroy() end
                esp = instance_new("Highlight")
                esp.Adornee = target.Parent
                esp.FillColor = silentSettings.highlightFillColor
                esp.OutlineColor = silentSettings.highlightOutlineColor
                esp.FillTransparency = silentSettings.highlightFillTransparency
                esp.OutlineTransparency = silentSettings.highlightOutlineTransparency
                esp.Parent = target.Parent
            end
            
            local function updateTracer(targetPosition)
                if not silentSettings.visualiseEnabled or not silentSettings.tracerEnabled then
                    tracerLine.Visible = false
                    return
                end
                
                if targetPosition then
                    tracerLine.Visible = true
                    tracerLine.From = uis:GetMouseLocation()
                    local screenPos, onScreen = camera:WorldToViewportPoint(targetPosition)
                    if onScreen then
                        tracerLine.To = vec2(screenPos.X, screenPos.Y)
                    else
                        tracerLine.Visible = false
                    end
                else
                    tracerLine.Visible = false
                end
            end
            
            local function destroyVisuals()
                if esp then esp:Destroy() end
                esp = nil
                tracerLine.Visible = false
            end
            
            local function getTarget()
                if silentSettings.stickyEnabled then
                    if silentSettings.stickyTarget and silentSettings.stickyTarget.Parent then
                        return silentSettings.stickyTarget
                    else
                        -- Захватываем новую цель если sticky включен
                        local checks = silentSettings.checksEnabled and {
                            checkKO = silentSettings.checkKO,
                            checkGrabbed = silentSettings.checkGrabbed,
                            checkForceField = silentSettings.checkForceField,
                            checkWall = silentSettings.checkWall
                        } or nil
                        local predX = silentSettings.predictionEnabled and silentSettings.customPredictionX or silentSettings.predictionX
                        local predY = silentSettings.predictionEnabled and silentSettings.customPredictionY or silentSettings.predictionY
                        silentSettings.stickyTarget = _G.silentUtility:getClosestPlayer(silentSettings.fovRadius, silentSettings.targetPart, silentSettings.useFov, checks, predX, predY)
                        return silentSettings.stickyTarget
                    end
                else
                    silentSettings.stickyTarget = nil
                    -- Свободный захват цели
                    local checks = silentSettings.checksEnabled and {
                        checkKO = silentSettings.checkKO,
                        checkGrabbed = silentSettings.checkGrabbed,
                        checkForceField = silentSettings.checkForceField,
                        checkWall = silentSettings.checkWall
                    } or nil
                    local predX = silentSettings.predictionEnabled and silentSettings.customPredictionX or silentSettings.predictionX
                    local predY = silentSettings.predictionEnabled and silentSettings.customPredictionY or silentSettings.predictionY
                    return _G.silentUtility:getClosestPlayer(silentSettings.fovRadius, silentSettings.targetPart, silentSettings.useFov, checks, predX, predY)
                end
            end
            
            -- Main Silent Aimbot Toggle
            local mainToggle = section:toggle({
                name = "Silent Aimbot", 
                flag = "silent_enabled",
                type = "toggle",
                callback = function(bool)
                    silentSettings.enabled = bool
                    if not bool then
                        destroyVisuals()
                        fovFrame.Visible = false
                    end
                end,
                seperator = true
            })
            
            -- Sticky Target Keybind  
            section:keybind({
                name = "Sticky Target",
                flag = "silent_sticky_key", 
                key = enum.KeyCode.C,
                mode = "Toggle",
                default = false,
                callback = function(active)
                    silentSettings.stickyEnabled = active
                end,
                seperator = true
            })
            
            -- FOV Toggle
            local fovToggle = section:toggle({
                name = "FOV", 
                flag = "silent_fov_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.useFov = bool
                end,
                seperator = true
            })
            
            -- FOV Settings Sub-section
            local fovSubSection = fovToggle:settings({})
            
            fovSubSection:slider({
                name = "FOV Size", 
                flag = "silent_fov_size",
                min = 50, 
                max = 500, 
                default = 350, 
                interval = 1,
                callback = function(value)
                    silentSettings.fovRadius = value
                    fovFrame.Size = udim2_offset(value * 2, value * 2)
                end,
                seperator = true
            })
            
            local showFovToggle = fovSubSection:toggle({
                name = "Show FOV", 
                flag = "silent_show_fov",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.showFov = bool
                    if not bool then
                        fovFrame.Visible = false
                    end
                end,
                seperator = true
            })
            
            showFovToggle:colorpicker({
                name = "FOV Color",
                flag = "silent_fov_color",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.fovColor = color
                    silentSettings.fovTransparency = transparency
                    fovCircle.Color = color
                    fovCircle.Transparency = transparency
                end
            })
            
            -- Visualise Toggle
            local visualiseToggle = section:toggle({
                name = "Visualise", 
                flag = "silent_visualise_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.visualiseEnabled = bool
                    if not bool then
                        destroyVisuals()
                    end
                end,
                seperator = true
            })
            
            -- Visualise Settings Sub-section
            local visualiseSubSection = visualiseToggle:settings({})
            
            -- Highlight Toggle
            local highlightToggle = visualiseSubSection:toggle({
                name = "Highlight", 
                flag = "silent_highlight_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.highlightEnabled = bool
                    if not bool and esp then
                        esp:Destroy()
                        esp = nil
                    end
                end,
                seperator = true
            })
            
            highlightToggle:colorpicker({
                name = "Fill Color",
                flag = "silent_highlight_fill",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.highlightFillColor = color
                    silentSettings.highlightFillTransparency = transparency
                    if esp then
                        esp.FillColor = color
                        esp.FillTransparency = transparency
                    end
                end
            })
            
            highlightToggle:colorpicker({
                name = "Outline Color",
                flag = "silent_highlight_outline",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.highlightOutlineColor = color
                    silentSettings.highlightOutlineTransparency = transparency
                    if esp then
                        esp.OutlineColor = color
                        esp.OutlineTransparency = transparency
                    end
                end
            })
            
            -- Tracer Toggle
            local tracerToggle = visualiseSubSection:toggle({
                name = "Tracer", 
                flag = "silent_tracer_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.tracerEnabled = bool
                    if not bool then
                        tracerLine.Visible = false
                    end
                end,
                seperator = true
            })
            
            tracerToggle:colorpicker({
                name = "Tracer Color",
                flag = "silent_tracer_color",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.tracerColor = color
                    -- Для Drawing API: больше fade = меньше прозрачности (инвертируем)
                    silentSettings.tracerTransparency = 1 - transparency
                    tracerLine.Color = color
                    tracerLine.Transparency = 1 - transparency
                end
            })
            
            -- Aimpart Dropdown
            section:dropdown({
                name = "Aimpart",
                flag = "silent_aimpart",
                items = {
                    "Head",
                    "UpperTorso", 
                    "LowerTorso",
                    "LeftUpperArm",
                    "LeftLowerArm",
                    "LeftHand",
                    "RightUpperArm",
                    "RightLowerArm", 
                    "RightHand",
                    "LeftUpperLeg",
                    "LeftLowerLeg",
                    "LeftFoot",
                    "RightUpperLeg",
                    "RightLowerLeg",
                    "RightFoot"
                },
                default = "Head",
                callback = function(selected)
                    silentSettings.targetPart = selected
                end,
                seperator = true
            })
            
            
            -- Checks Toggle
            local checksToggle = section:toggle({
                name = "Checks", 
                flag = "silent_checks_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checksEnabled = bool
                end,
                seperator = true
            })
            
            -- Checks Settings Sub-section
            local checksSubSection = checksToggle:settings({})
            
            -- KO Check
            checksSubSection:toggle({
                name = "Check K.O",
                flag = "silent_check_ko",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkKO = bool
                end,
                seperator = true
            })
            
            -- Grabbed Check
            checksSubSection:toggle({
                name = "Check Grabbed",
                flag = "silent_check_grabbed",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkGrabbed = bool
                end,
                seperator = true
            })
            
            -- ForceField Check
            checksSubSection:toggle({
                name = "Check ForceField",
                flag = "silent_check_forcefield",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkForceField = bool
                end,
                seperator = true
            })
            
            -- Wall Check
            checksSubSection:toggle({
                name = "Check Wall",
                flag = "silent_check_wall",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkWall = bool
                end,
                seperator = true
            })
            
            -- Prediction Toggle
            local predictionToggle = section:toggle({
                name = "Prediction", 
                flag = "silent_prediction_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.predictionEnabled = bool
                end,
                seperator = true
            })
            
            -- Prediction Settings Sub-section
            local predictionSubSection = predictionToggle:settings({})
            
            -- Prediction X Textbox
            predictionSubSection:textbox({
                name = "Prediction X",
                flag = "silent_prediction_x",
                placeholder = "0.021111111",
                callback = function(text)
                    local value = tonumber(text)
                    if value then
                        silentSettings.customPredictionX = value
                    end
                end,
                seperator = true
            })
            
            -- Prediction Y Textbox
            predictionSubSection:textbox({
                name = "Prediction Y",
                flag = "silent_prediction_y",
                placeholder = "0.0102",
                callback = function(text)
                    local value = tonumber(text)
                    if value then
                        silentSettings.customPredictionY = value
                    end
                end,
                seperator = true
            })
            
            -- Resolver Toggle
            local resolverToggle = section:toggle({
                name = "Resolver", 
                flag = "silent_resolver_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.resolverEnabled = bool
                end,
                seperator = true
            })
            
            -- Resolver Settings Sub-section
            local resolverSubSection = resolverToggle:settings({})
            
            -- Resolver Mode Dropdown
            resolverSubSection:dropdown({
                name = "Resolver Mode",
                flag = "silent_resolver_mode",
                items = {
                    "Velocity",
                    "MoveDirection", 
                    "CalculateCFrame"
                },
                default = "Velocity",
                callback = function(selected)
                    silentSettings.resolverMode = selected
                end,
                seperator = true
            })
            
            -- Main Loop
            run.RenderStepped:Connect(function()
                if fovFrame and silentSettings.showFov and silentSettings.useFov then
                    local mousePos = uis:GetMouseLocation()
                    fovFrame.Position = udim2_offset(mousePos.X, mousePos.Y - gui_offset)
                    fovFrame.Visible = true
                else
                    fovFrame.Visible = false
                end
                
                if not silentSettings.enabled then
                    destroyVisuals()
                    return
                end
                
                local target = getTarget()
                if target then
                    local predictedPosition = _G.silentUtility:predict(target, silentSettings.predictionX, silentSettings.predictionY)
                    if predictedPosition then
                        highlightPlayer(target)
                        updateTracer(predictedPosition)
                    else
                        destroyVisuals()
                    end
                else
                    destroyVisuals()
                end
            end)
            
            -- AIMBOT HOOK
            local __aimbot
            __aimbot = hookmetamethod(game, "__index", newcclosure(function(t, k)
                if t:IsA("Mouse") and (k == "Hit" or k == "Target") then
                    if not (silentSettings.enabled and getTarget()) then
                        return __aimbot(t, k)
                    end
                    
                    local target = getTarget()
                    if target then
                        local predictedPosition = _G.silentUtility:predict(target, silentSettings.predictionX, silentSettings.predictionY)
                        if predictedPosition then
                            local hit = cfr(predictedPosition)
                            return k == "Hit" and hit or target
                        end
                    end
                end
                return __aimbot(t, k)
            end))
            
        end
    end
    
    -- Other Section
    do
        local OtherSection = OtherTab:column({})
        local section = OtherSection:section({name = "Other", default = false})
        
        -- HitboxExpander Toggle
        local hitboxExpanderToggle = section:toggle({
            name = "Hitbox Expander",
            flag = "hitbox_expander_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.hitboxExpanderSettings.enabled = bool
                if bool then
                    _G.StartHitboxExpander()
                else
                    _G.StopHitboxExpander()
                end
            end,
            info = "Увеличивает хитбоксы игроков для упрощения попадания"
        })
        
        -- HitboxExpander Settings
        local hitboxExpanderSettings = hitboxExpanderToggle:settings({})
        
        hitboxExpanderSettings:textbox({
            name = "Hitbox Size",
            flag = "hitbox_expander_size",
            placeholder = "10",
            default = "10",
            callback = function(text)
                local value = tonumber(text)
                if value then
                    _G.hitboxExpanderSettings.size = value
                end
            end,
            info = "Размер увеличенного хитбокса (рекомендуется 5-20)"
        })
        
        hitboxExpanderSettings:toggle({
            name = "Visible Hitboxes",
            flag = "hitbox_expander_visible",
            type = "checkbox",
            default = false,
            callback = function(bool)
                _G.hitboxExpanderSettings.visible = bool
            end,
            info = "Показывать увеличенные хитбоксы визуально"
        })
        
        -- NoRecoil Toggle
        section:toggle({
            name = "No Recoil",
            flag = "no_recoil_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.noRecoilSettings.enabled = bool
            end,
            info = "Убирает отдачу оружия через блокировку CFrame камеры"
        })
        
        -- NoSpread Toggle
        local noSpreadToggle = section:toggle({
            name = "No Spread",
            flag = "no_spread_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.noSpreadSettings.enabled = bool
            end,
            info = "Убирает разброс оружия через хук math.random"
        })
        
        -- NoSpread Settings
        local noSpreadSettings = noSpreadToggle:settings({})
        
        noSpreadSettings:slider({
            name = "Spread Amount",
            flag = "no_spread_amount",
            min = 0,
            max = 100,
            default = 0,
            interval = 1,
            suffix = "%",
            callback = function(value)
                _G.noSpreadSettings.amount = value
            end,
            info = "Сила разброса (0% = нет разброса, 100% = полный разброс)"
        })
    end
end

-- // Visuals Tab  
do
    local VisualsTab, ESPTab = window:tab({
        name = "Visuals", 
        icon = "rbxassetid://10723346959",  -- lucide-eye
        tabs = {"General", "ESP"}
    })
    
    -- General Visuals Section
    do
        local VisualsSection = VisualsTab:column({})
        local section = VisualsSection:section({name = "General", default = false})
        
        -- SelfMaterial Toggle
        local selfMaterialToggle = section:toggle({
            name = "SelfMaterial",
            flag = "self_material_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.selfMaterialSettings.enabled = bool
                
                if bool then
                    _G.StartSelfMaterial()
                else
                    _G.StopSelfMaterial()
                end
            end,
            info = "Изменяет материал и цвет вашего персонажа"
        })
        
        -- SelfMaterial Settings
        local selfMaterialSettings = selfMaterialToggle:settings({})
        
        -- Character Color Picker
        selfMaterialSettings:colorpicker({
            name = "Character Color",
            flag = "self_material_color",
            default = rgb(255, 0, 0),
            callback = function(color)
                _G.selfMaterialSettings.color = color
            end,
            info = "Цвет персонажа"
        })
        
        -- SelfHighlight Toggle
        local selfHighlightToggle = section:toggle({
            name = "SelfHighlight",
            flag = "self_highlight_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.selfHighlightSettings.enabled = bool
                
                if bool then
                    _G.StartSelfHighlight()
                else
                    _G.StopSelfHighlight()
                end
            end,
            info = "Добавляет подсветку вашему персонажу"
        })
        
        -- SelfHighlight Settings
        local selfHighlightSettings = selfHighlightToggle:settings({})
        
        -- Fill Color Picker with Fade
        selfHighlightSettings:colorpicker({
            name = "Fill Color",
            flag = "self_highlight_fill_color",
            default = rgb(255, 0, 0),
            fade = true,
            callback = function(color, fade)
                _G.selfHighlightSettings.fillColor = color
                _G.selfHighlightSettings.fillTransparency = 1 - fade
                _G.UpdateSelfHighlight()
            end,
            info = "Цвет и прозрачность заливки подсветки"
        })
        
        -- Outline Color Picker with Fade
        selfHighlightSettings:colorpicker({
            name = "Outline Color",
            flag = "self_highlight_outline_color",
            default = rgb(255, 255, 255),
            fade = true,
            callback = function(color, fade)
                _G.selfHighlightSettings.outlineColor = color
                _G.selfHighlightSettings.outlineTransparency = 1 - fade
                _G.UpdateSelfHighlight()
            end,
            info = "Цвет и прозрачность контура подсветки"
        })
        
        -- GunMaterial Toggle
        local gunMaterialToggle = section:toggle({
            name = "GunMaterial",
            flag = "gun_material_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.gunMaterialSettings.enabled = bool
                
                if bool then
                    _G.StartGunMaterial()
                else
                    _G.StopGunMaterial()
                end
            end,
            info = "Изменяет материал и цвет оружия в руках"
        })
        
        -- GunMaterial Settings
        local gunMaterialSettings = gunMaterialToggle:settings({})
        
        -- Gun Color Picker
        gunMaterialSettings:colorpicker({
            name = "Gun Color",
            flag = "gun_material_color",
            default = rgb(255, 0, 0),
            callback = function(color)
                _G.gunMaterialSettings.color = color
            end,
            info = "Цвет оружия (материал ForceField)"
        })
        
        -- GunHighlight Toggle
        local gunHighlightToggle = section:toggle({
            name = "GunHighlight",
            flag = "gun_highlight_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.gunHighlightSettings.enabled = bool
                
                if bool then
                    _G.StartGunHighlight()
                else
                    _G.StopGunHighlight()
                end
            end,
            info = "Добавляет подсветку оружию в руках"
        })
        
        -- GunHighlight Settings
        local gunHighlightSettings = gunHighlightToggle:settings({})
        
        -- Fill Color Picker with Fade
        gunHighlightSettings:colorpicker({
            name = "Fill Color",
            flag = "gun_highlight_fill_color",
            default = rgb(255, 0, 0),
            fade = true,
            callback = function(color, fade)
                _G.gunHighlightSettings.fillColor = color
                _G.gunHighlightSettings.fillTransparency = 1 - fade
                _G.UpdateGunHighlight()
            end,
            info = "Цвет и прозрачность заливки подсветки оружия"
        })
        
        -- Outline Color Picker with Fade
        gunHighlightSettings:colorpicker({
            name = "Outline Color",
            flag = "gun_highlight_outline_color",
            default = rgb(255, 255, 255),
            fade = true,
            callback = function(color, fade)
                _G.gunHighlightSettings.outlineColor = color
                _G.gunHighlightSettings.outlineTransparency = 1 - fade
                _G.UpdateGunHighlight()
            end,
            info = "Цвет и прозрачность контура подсветки оружия"
        })
    end
    
    -- ESP Section
    do
        local ESPSection = ESPTab:column({})
        local section = ESPSection:section({name = "ESP", default = false})
        
        -- Box ESP Toggle
        local boxESPToggle = section:toggle({
            name = "Box ESP",
            flag = "box_esp_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                -- Устанавливаем boolean значение в flags
                library.flags["box_esp_enabled"] = bool
                
                if bool then
                    -- // create esp for all players
                    for _, player in ipairs(players:GetPlayers()) do
                        if player ~= lp and player.Character then
                            local espData = _G.espFramework:getESP(player)
                            if not espData then
                                espData = _G.espFramework:createBox(player)
                                if espData then
                                    _G.espFramework:setESP(player, espData)
                                    _G.espFramework:applySettings(espData, library.flags)
                                end
                            end
                        end
                    end
                    _G.espFramework:startESP()
                else
                    -- Проверяем нужно ли останавливать ESP
                    _G.espFramework:checkESPState()
                end
            end,
            info = "Показывает рамки вокруг игроков"
        })
        
        -- Box ESP Settings
        local boxESPSettings = boxESPToggle:settings({})
        
        -- Box Colors
        boxESPSettings:colorpicker({
            name = "Box Color 1",
            flag = "box_color_1",
            default = rgb(255, 255, 255),
            callback = function(color)
                -- Устанавливаем цвет в flags
                library.flags["box_color_1"] = {Color = color}
                
                if not library.flags["box_esp_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Первый цвет градиента рамки"
        })
        
        boxESPSettings:colorpicker({
            name = "Box Color 2",
            flag = "box_color_2",
            default = rgb(255, 255, 255),
            callback = function(color)
                if not library.flags["box_esp_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Второй цвет градиента рамки"
        })
        
        boxESPSettings:colorpicker({
            name = "Box Color 3",
            flag = "box_color_3",
            default = rgb(255, 255, 255),
            callback = function(color)
                if not library.flags["box_esp_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Третий цвет градиента рамки"
        })
        
        boxESPSettings:colorpicker({
            name = "Box Color 4",
            flag = "box_color_4",
            default = rgb(255, 255, 255),
            callback = function(color)
                if not library.flags["box_esp_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Четвертый цвет градиента рамки"
        })
        
        -- Gradient Rotation Slider
        boxESPSettings:slider({
            name = "Gradient Rotation",
            flag = "box_gradient_rotation",
            min = 0,
            max = 360,
            default = 90,
            interval = 1,
            suffix = "°",
            callback = function(value)
                if not library.flags["box_esp_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Поворот градиента рамки в градусах"
        })
        
        -- Health Bar ESP Toggle (отдельный от Box ESP)
        local healthBarToggle = section:toggle({
            name = "Health Bar",
            flag = "healthbar_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                -- Устанавливаем boolean значение в flags
                library.flags["healthbar_enabled"] = bool
                
                if bool then
                    -- // create esp for all players
                    for _, player in ipairs(players:GetPlayers()) do
                        if player ~= lp and player.Character then
                            local espData = _G.espFramework:getESP(player)
                            if not espData then
                                espData = _G.espFramework:createBox(player)
                                if espData then
                                    _G.espFramework:setESP(player, espData)
                                    _G.espFramework:applySettings(espData, library.flags)
                                end
                            end
                        end
                    end
                    _G.espFramework:startESP()
                else
                    -- Проверяем нужно ли останавливать ESP
                    _G.espFramework:checkESPState()
                end
            end,
            info = "Показывает полоски здоровья игроков"
        })
        
        -- Health Bar Settings
        local healthBarSettings = healthBarToggle:settings({})
        
        -- Health Bar Colors
        healthBarSettings:colorpicker({
            name = "Health Color 1",
            flag = "healthbar_color_1",
            default = rgb(0, 255, 0),
            callback = function(color)
                -- Устанавливаем цвет в flags
                library.flags["healthbar_color_1"] = {Color = color}
                
                if not library.flags["healthbar_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Первый цвет градиента здоровья"
        })
        
        healthBarSettings:colorpicker({
            name = "Health Color 2",
            flag = "healthbar_color_2",
            default = rgb(0, 255, 0),
            callback = function(color)
                if not library.flags["healthbar_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Второй цвет градиента здоровья"
        })
        
        healthBarSettings:colorpicker({
            name = "Health Color 3",
            flag = "healthbar_color_3",
            default = rgb(0, 255, 0),
            callback = function(color)
                if not library.flags["healthbar_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Третий цвет градиента здоровья"
        })
        
        healthBarSettings:colorpicker({
            name = "Health Color 4",
            flag = "healthbar_color_4",
            default = rgb(0, 255, 0),
            callback = function(color)
                if not library.flags["healthbar_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Четвертый цвет градиента здоровья"
        })
        
        -- Health Bar Gradient Rotation Slider
        healthBarSettings:slider({
            name = "Health Gradient Rotation",
            flag = "healthbar_gradient_rotation",
            min = 0,
            max = 360,
            default = 90,
            interval = 1,
            suffix = "°",
            callback = function(value)
                if not library.flags["healthbar_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Поворот градиента здоровья в градусах"
        })
        
        -- Armor Bar ESP Toggle (отдельный от Health Bar)
        local armorBarToggle = section:toggle({
            name = "Armor Bar",
            flag = "armorbar_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                -- Устанавливаем boolean значение в flags
                library.flags["armorbar_enabled"] = bool
                
                if bool then
                    -- // create esp for all players
                    for _, player in ipairs(players:GetPlayers()) do
                        if player ~= lp and player.Character then
                            local espData = _G.espFramework:getESP(player)
                            if not espData then
                                espData = _G.espFramework:createBox(player)
                                if espData then
                                    _G.espFramework:setESP(player, espData)
                                    _G.espFramework:applySettings(espData, library.flags)
                                end
                            end
                        end
                    end
                    _G.espFramework:startESP()
                else
                    -- Проверяем нужно ли останавливать ESP
                    _G.espFramework:checkESPState()
                end
            end,
            info = "Показывает полоски брони игроков"
        })
        
        -- Armor Bar Settings
        local armorBarSettings = armorBarToggle:settings({})
        
        -- Armor Bar Colors
        armorBarSettings:colorpicker({
            name = "Armor Color 1",
            flag = "armorbar_color_1",
            default = rgb(0, 150, 255),
            callback = function(color)
                if not library.flags["armorbar_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Первый цвет градиента брони"
        })
        
        armorBarSettings:colorpicker({
            name = "Armor Color 2",
            flag = "armorbar_color_2",
            default = rgb(0, 150, 255),
            callback = function(color)
                if not library.flags["armorbar_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Второй цвет градиента брони"
        })
        
        armorBarSettings:colorpicker({
            name = "Armor Color 3",
            flag = "armorbar_color_3",
            default = rgb(0, 150, 255),
            callback = function(color)
                if not library.flags["armorbar_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Третий цвет градиента брони"
        })
        
        armorBarSettings:colorpicker({
            name = "Armor Color 4",
            flag = "armorbar_color_4",
            default = rgb(0, 150, 255),
            callback = function(color)
                if not library.flags["armorbar_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Четвертый цвет градиента брони"
        })
        
        -- Armor Bar Gradient Rotation Slider
        armorBarSettings:slider({
            name = "Armor Gradient Rotation",
            flag = "armorbar_gradient_rotation",
            min = 0,
            max = 360,
            default = 90,
            interval = 1,
            suffix = "°",
            callback = function(value)
                if not library.flags["armorbar_enabled"] then return end
                for _, player in ipairs(players:GetPlayers()) do
                    local espData = _G.espFramework:getESP(player)
                    if espData then 
                        _G.espFramework:applySettings(espData, library.flags) 
                    end
                end
            end,
            info = "Поворот градиента брони в градусах"
        })
        
        -- Highlight Chams Toggle
        local highlightChamsToggle = section:toggle({
            name = "Highlight Chams",
            flag = "highlight_chams_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                -- Устанавливаем boolean значение в flags
                library.flags["highlight_chams_enabled"] = bool
                
                if bool then
                    -- Создаем highlight для всех игроков
                    for _, player in ipairs(players:GetPlayers()) do
                        if player ~= lp and player.Character then
                            _G.espFramework:createHighlight(player)
                        end
                    end
                else
                    -- Удаляем все highlight
                    _G.espFramework:clearAllHighlights()
                end
            end,
            info = "Подсвечивает игроков через стены"
        })
        
        -- Highlight Chams Settings
        local highlightSettings = highlightChamsToggle:settings({})
        
        -- Fill Color
        highlightSettings:colorpicker({
            name = "Fill Color",
            flag = "highlight_fill_color",
            color = rgb(255, 0, 0),
            alpha = 0.5,
            callback = function(color, alpha)
                -- Устанавливаем цвет и прозрачность в flags
                library.flags["highlight_fill_color"] = {Color = color}
                library.flags["highlight_fill_transparency"] = alpha
                
                if not library.flags["highlight_chams_enabled"] then return end
                _G.espFramework:updateAllHighlights(library.flags)
            end,
            info = "Цвет и прозрачность заливки highlight"
        })
        
        -- Outline Color
        highlightSettings:colorpicker({
            name = "Outline Color",
            flag = "highlight_outline_color",
            color = rgb(255, 255, 255),
            alpha = 0,
            callback = function(color, alpha)
                -- Устанавливаем цвет и прозрачность в flags
                library.flags["highlight_outline_color"] = {Color = color}
                library.flags["highlight_outline_transparency"] = alpha
                
                if not library.flags["highlight_chams_enabled"] then return end
                _G.espFramework:updateAllHighlights(library.flags)
            end,
            info = "Цвет и прозрачность обводки highlight"
        })
        
        -- Material Chams Toggle
        local materialChamsToggle = section:toggle({
            name = "Material Chams",
            flag = "material_chams_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                -- Устанавливаем boolean значение в flags
                library.flags["material_chams_enabled"] = bool
                
                if bool then
                    -- Применяем neon материал ко всем игрокам
                    _G.espFramework:setAllPlayersMaterial("Neon")
                else
                    -- Однократно возвращаем plastic материал и останавливаем обновления
                    _G.espFramework:setAllPlayersMaterial("Plastic")
                end
            end,
            info = "Меняет материал игроков на светящийся"
        })
        
        -- Material Chams Settings
        local materialSettings = materialChamsToggle:settings({})
        
        -- Material Color
        materialSettings:colorpicker({
            name = "Material Color",
            flag = "material_chams_color",
            color = rgb(255, 255, 255),
            alpha = 1,
            callback = function(color, alpha)
                -- Устанавливаем цвет материала в flags
                library.flags["material_chams_color"] = {Color = color}
                
                if not library.flags["material_chams_enabled"] then return end
                _G.espFramework:updateAllMaterialColors(library.flags)
            end,
            info = "Цвет материала для chams"
        })
        
    end
end

-- // Misc Tab
do
    local MiscTab, LoadoutTab, MovementTab = window:tab({
        name = "Misc", 
        icon = "rbxassetid://10734934585",  -- lucide-rocket
        tabs = {"General", "Loadout", "Movement"}
    })
    
    -- General Misc Section
    do
        local MiscSection = MiscTab:column({})
        local section = MiscSection:section({name = "General", default = false})
        
        -- AntiStomp Toggle
        local antiStompToggle = section:toggle({
            name = "AntiStomp",
            flag = "anti_stomp_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.antiStompSettings.enabled = bool
                if bool then
                    _G.StartAntiStomp()
                else
                    _G.StopAntiStomp()
                end
            end,
            info = "Автоматически вызывает смерть при низком HP"
        })
        
        -- AntiStomp Settings
        local antiStompSettings = antiStompToggle:settings({})
        
        antiStompSettings:slider({
            name = "HP Threshold",
            flag = "anti_stomp_hp",
            min = 1,
            max = 99,
            default = 10,
            suffix = " HP",
            callback = function(value)
                _G.antiStompSettings.hpThreshold = value
            end,
            info = "HP при котором будет вызвана смерть"
        })
        
        -- VelocityBreaker Toggle
        local velocityBreakerToggle = section:toggle({
            name = "VelocityBreaker",
            flag = "velocity_breaker_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.velocityBreakerSettings.enabled = bool
                if bool then
                    _G.StartVelocityBreaker()
                else
                    _G.StopVelocityBreaker()
                end
            end,
            info = "Изменяет скорость игрока для анти-эйма"
        })
        
        -- VelocityBreaker Settings
        local velocityBreakerSettings = velocityBreakerToggle:settings({})
        
        velocityBreakerSettings:slider({
            name = "Velocity X",
            flag = "velocity_breaker_x",
            min = 0,
            max = 100,
            default = 0,
            callback = function(value)
                _G.velocityBreakerSettings.velocityX = value
            end,
            info = "Скорость по оси X"
        })
        
        velocityBreakerSettings:slider({
            name = "Velocity Y",
            flag = "velocity_breaker_y",
            min = 0,
            max = 100,
            default = 0,
            callback = function(value)
                _G.velocityBreakerSettings.velocityY = value
            end,
            info = "Скорость по оси Y"
        })
        
        velocityBreakerSettings:slider({
            name = "Velocity Z",
            flag = "velocity_breaker_z",
            min = 0,
            max = 100,
            default = 0,
            callback = function(value)
                _G.velocityBreakerSettings.velocityZ = value
            end,
            info = "Скорость по оси Z"
        })
        
        -- AntiFling Toggle
        section:toggle({
            name = "AntiFling",
            flag = "anti_fling_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.antiFlingSettings.enabled = bool
                if bool then
                    _G.StartAntiFling()
                else
                    _G.StopAntiFling()
                end
            end,
            info = "Отключает коллизии других игроков для предотвращения флинга"
        })
        
        -- AntiInertia Toggle
        section:toggle({
            name = "Anti Inertia",
            flag = "anti_inertia_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.ToggleAntiInertia(bool)
            end,
            info = "Убирает инерцию движения для более точного контроля"
        })
        
        -- LagSwitch Toggle
        local lagSwitchToggle = section:toggle({
            name = "LagSwitch",
            flag = "lag_switch_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.lagSwitchSettings.enabled = bool
                if bool then
                    _G.StartLagSwitch()
                else
                    _G.StopLagSwitch()
                end
            end,
            info = "Создает лаг-десинк для анти-эйма через изменение сетевых флагов"
        })
        
        -- LagSwitch Settings
        local lagSwitchSettings = lagSwitchToggle:settings({})
        
        lagSwitchSettings:slider({
            name = "Desync Delay",
            flag = "lag_switch_desync_delay",
            min = 0.1,
            max = 5.0,
            default = 1.2,
            interval = 0.1,
            suffix = "s",
            callback = function(value)
                _G.lagSwitchSettings.desyncDelay = value
            end,
            info = "Задержка между циклами десинка (фриз + анфриз + пауза)"
        })
    end
    
    -- Loadout Section
    do
        local LoadoutSection = LoadoutTab:column({})
        local section = LoadoutSection:section({name = "Auto Buy", default = true})
        
        -- AutoArmor Toggle
        local autoArmorToggle = section:toggle({
            name = "AutoArmor",
            flag = "auto_armor_enabled",
            type = "toggle",
            callback = function(bool)
                _G.autoBuySettings.autoArmor.enabled = bool
                if bool then
                    _G.StartAutoBuy()
                else
                    _G.StopAutoBuy()
                end
            end,
        })
        
        -- AutoArmor Settings
        local armorSettings = autoArmorToggle:settings({})
        armorSettings:keybind({
            name = "Auto Armor Key",
            flag = "auto_armor_key",
            key = enum.KeyCode.F1,
            mode = "Toggle",
            callback = function(active)
                library.config_flags["auto_armor_enabled"](active)
                _G.autoBuySettings.autoArmor.enabled = active
                if active then
                    _G.StartAutoBuy()
                else
                    _G.StopAutoBuy()
                end
            end
        })
        
        armorSettings:slider({
            name = "Armor Value",
            flag = "auto_armor_value",
            min = 1,
            max = 129,
            default = 120,
            suffix = " HP",
            callback = function(value)
                _G.autoBuySettings.autoArmor.armorValue = value
            end,
            info = "Значение брони при котором будет покупаться новая броня"
        })
        
        -- AutoGuns Toggle
        local autoGunsToggle = section:toggle({
            name = "Auto Guns",
            flag = "auto_guns_enabled",
            type = "toggle",
            callback = function(bool)
                _G.autoBuySettings.autoGuns.enabled = bool
            end
        })
        
        -- AutoGuns Settings
        local gunsSettings = autoGunsToggle:settings({})
        
        gunsSettings:keybind({
            name = "Auto Guns Key",
            flag = "auto_guns_key",
            key = enum.KeyCode.F2,
            mode = "Toggle",
            callback = function(active)
                library.config_flags["auto_guns_enabled"](active)
                _G.autoBuySettings.autoGuns.enabled = active
            end
        })
        
        gunsSettings:dropdown({
            name = "Weapon Selection",
            flag = "auto_guns_weapon",
            items = {
                "[Rifle]", "[LMG]", "[P90]", "[Flintlock]", "[Revolver]", 
                "[Double-Barrel SG]", "[AK47]", "[TacticalShotgun]", 
                "[SMG]", "[AR]", "[Silencer]", "[Shotgun]"
            },
            default = {"[Rifle]", "[LMG]"},
            multi = true,
            callback = function(selectedWeapons)
                _G.autoBuySettings.autoGuns.selectedWeapons = selectedWeapons
                -- Update WEAPONS table to enable only selected weapons
                for _, weaponData in ipairs(_G.WEAPONS or {}) do
                    weaponData.Enabled = false
                    for _, selectedWeapon in ipairs(selectedWeapons) do
                        if weaponData.Name == selectedWeapon then
                            weaponData.Enabled = true
                            break
                        end
                    end
                end
            end,
            info = "Выберите оружие для автопокупки (можно несколько)"
        })
        
        -- AutoAmmo Toggle
        local autoAmmoToggle = section:toggle({
            name = "Auto Ammo",
            flag = "auto_ammo_enabled",
            type = "toggle",
            callback = function(bool)
                _G.autoBuySettings.autoAmmo.enabled = bool
            end
        })
        
        -- AutoAmmo Settings
        local ammoSettings = autoAmmoToggle:settings({})
        
        ammoSettings:keybind({
            name = "Auto Ammo Key",
            flag = "auto_ammo_key",
            key = enum.KeyCode.F3,
            mode = "Toggle",
            callback = function(active)
                library.config_flags["auto_ammo_enabled"](active)
                _G.autoBuySettings.autoAmmo.enabled = active
            end
        })
    end
    
    -- Movement Section
    do
        local MovementSection = MovementTab:column({})
        local section = MovementSection:section({name = "Movement", default = false})
        
        -- SpeedHack Toggle
        local speedHackToggle = section:toggle({
            name = "SpeedHack",
            flag = "speed_hack_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.speedHackSettings.enabled = bool
                if bool then
                    _G.StartSpeedHack()
                else
                    _G.StopSpeedHack()
                end
            end,
            info = "Увеличивает скорость передвижения через CFrame"
        })
        
        -- SpeedHack Settings
        local speedHackSettings = speedHackToggle:settings({})
        
        speedHackSettings:textbox({
            name = "Speed Value",
            flag = "speed_hack_value",
            placeholder = "1",
            default = "1",
            callback = function(text)
                local value = tonumber(text)
                if value then
                    _G.speedHackSettings.speed = value
                end
            end,
            info = "Значение скорости (рекомендуется 1-5)"
        })
        
        speedHackSettings:keybind({
            name = "SpeedHack Key",
            flag = "speed_hack_key",
            key = enum.KeyCode.LeftShift,
            mode = "Toggle",
            default = false,
            callback = function(active)
                -- Кейбинд переключает состояние основного тогла
                library.config_flags["speed_hack_enabled"](active)
                _G.speedHackSettings.enabled = active
                if active then
                    _G.StartSpeedHack()
                else
                    _G.StopSpeedHack()
                end
            end,
            info = "Клавиша для переключения SpeedHack"
        })
        
        -- FlyHack Toggle
        local flyHackToggle = section:toggle({
            name = "FlyHack",
            flag = "fly_hack_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.flyHackSettings.enabled = bool
                if bool then
                    _G.StartFlyHack()
                else
                    _G.StopFlyHack()
                end
            end,
            info = "Позволяет летать с помощью CFrame (Space - вверх, Shift - вниз)"
        })
        
        -- FlyHack Settings
        local flyHackSettings = flyHackToggle:settings({})
        
        flyHackSettings:textbox({
            name = "Fly Speed",
            flag = "fly_hack_speed",
            placeholder = "50",
            default = "50",
            callback = function(text)
                local value = tonumber(text)
                if value then
                    _G.flyHackSettings.speed = value
                end
            end,
            info = "Скорость полета (рекомендуется 30-100)"
        })
        
        flyHackSettings:keybind({
            name = "FlyHack Key",
            flag = "fly_hack_key",
            key = enum.KeyCode.F,
            mode = "Toggle",
            default = false,
            callback = function(active)
                -- Кейбинд переключает состояние основного тогла
                library.config_flags["fly_hack_enabled"](active)
                _G.flyHackSettings.enabled = active
                if active then
                    _G.StartFlyHack()
                else
                    _G.StopFlyHack()
                end
            end,
            info = "Клавиша для переключения FlyHack"
        })
        
        -- NoJumpCooldown Toggle
        section:toggle({
            name = "No Jump Cooldown",
            flag = "no_jump_cooldown_enabled",
            type = "toggle",
            default = false,
            callback = function(bool)
                _G.noJumpCooldownSettings.enabled = bool
            end,
            info = "Убирает кулдаун прыжка через хук __newindex"
        })
    end
end

-- // Settings Tab
do
    
    local SettingsTab, ConfigsTab = window:tab({
        name = "Settings", 
        icon = "rbxassetid://10734950309",  -- lucide-settings
        tabs = {"Main", "Configs"}
    })
    
    -- Settings Section
    do
        local SettingsSection = SettingsTab:column({})
        local section = SettingsSection:section({name = "Settings", default = false})
        
        -- Set default accent color
        library:update_theme("accent", rgb(0, 169, 255))
        
        -- Menu Keybind
        section:keybind({
            name = "Menu Keybind", 
            key = Enum.KeyCode.RightControl,
            mode = "Toggle",
            default = false,
            callback = function(bool) 
                window.toggle_menu(bool) 
            end,
            info = "Клавиша для открытия/закрытия меню"
        })
        
        -- Game Interaction Buttons
        section:button({
            name = "Copy JobId",
            callback = function()
                setclipboard(game.JobId)
                library.notifications:create_notification({
                    name = "JobId Copied",
                    info = "JobId copied to clipboard!",
                    lifetime = 3
                })
            end,
            info = "Copy current server JobId to clipboard"
        })
        
        section:button({
            name = "Copy GameID",
            callback = function()
                setclipboard(game.GameId)
                library.notifications:create_notification({
                    name = "GameID Copied",
                    info = "GameID copied to clipboard!",
                    lifetime = 3
                })
            end,
            info = "Copy current game ID to clipboard"
        })
        
        section:button({
            name = "Copy Join Script",
            callback = function()
                setclipboard(
                    'game:GetService("TeleportService"):TeleportToPlaceInstance(' ..
                        game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)'
                )
                library.notifications:create_notification({
                    name = "Join Script Copied",
                    info = "Join script copied to clipboard!",
                    lifetime = 3
                })
            end,
            info = "Copy teleport script to join this server"
        })
        
        section:button({
            name = "Rejoin",
            callback = function()
                game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, lp)
            end,
            info = "Rejoin current server"
        })
        
        section:button({
            name = "Join New Server",
            callback = function()
                local serverData = 
                    http_service:JSONDecode(
                    game:HttpGetAsync(
                        "https://games.roblox.com/v1/games/" ..
                            game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
                    )
                )
                local validServers = {}
                for _, server in pairs(serverData.data) do
                    if server.playing >= library.flags["min_players"] and server.playing <= library.flags["max_players"] then
                        insert(validServers, server)
                    end
                end
                
                if #validServers > 0 then
                    local randomServer = validServers[random(1, #validServers)]
                    game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, randomServer.id)
                else
                    library.notifications:create_notification({
                        name = "No Servers Found",
                        info = "No servers found matching player count criteria!",
                        lifetime = 3
                    })
                end
            end,
            info = "Join a random server within player count range"
        })
        
        section:slider({
            name = "Min Players", 
            flag = "min_players", 
            min = 0, 
            max = 40, 
            default = 1, 
            interval = 1,
            info = "Minimum number of players required on server"
        })
        
        section:slider({
            name = "Max Players", 
            flag = "max_players", 
            min = 0, 
            max = 40, 
            default = 15, 
            interval = 1,
            info = "Maximum number of players allowed on server"
        })
        
        -- Notification Test Button
        section:button({
            name = "Notification Test", 
            callback = function()
                library.notifications:create_notification({
                    name = "Test Notification",
                    info = "This is a test notification with random colors!",
                    lifetime = 5
                })
            end
        })
    end
    
    -- Configs Section
    do
        local ConfigsSection = ConfigsTab:column({})
        local section = ConfigsSection:section({name = "Configs", default = true})
        
        local ConfigName = ""
        local ConfigSelected = ""
        
        -- Config List
        local configList = section:dropdown({
            name = "Configs",
            items = {"Default Config"},
            callback = function(selected)
                ConfigSelected = selected
                print("Config Selected:", selected)
            end,
            flag = "config_list"
        })
        
        -- Config Name Input
        section:textbox({
            name = "Config Name", 
            placeholder = "Enter config name...",
            callback = function(text)
                ConfigName = text
            end,
            flag = "config_name_input"
        })
        
        -- Create Config Button
        section:button({
            name = "Create Config", 
            callback = function()
                if ConfigName ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigName .. ".cfg"
                    if not isfile(configPath) then
                        writefile(configPath, library:get_config())
                        
                        -- Обновляем dropdown
                        local configFiles = {}
                        for idx, file in listfiles(library.directory .. "/configs") do
                            local name = file:gsub(library.directory .. "/configs\\", ""):gsub(".cfg", ""):gsub(library.directory .. "\\configs\\", "")
                            insert(configFiles, name)
                        end
                        configList.refresh_options(configFiles)
                        
                        library.notifications:create_notification({
                            name = "Config Created",
                            info = "Config '" .. ConfigName .. "' created successfully!",
                            lifetime = 3
                        })
                    else
                        library.notifications:create_notification({
                            name = "Error",
                            info = "Config '" .. ConfigName .. "' already exists!",
                            lifetime = 3
                        })
                    end
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please enter a config name!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Load Config Button
        section:button({
            name = "Load Config", 
            callback = function()
                if ConfigSelected ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigSelected .. ".cfg"
                    if isfile(configPath) then
                        library:load_config(readfile(configPath))
                        library.notifications:create_notification({
                            name = "Config Loaded",
                            info = "Config '" .. ConfigSelected .. "' loaded successfully!",
                            lifetime = 3
                        })
                    else
                        library.notifications:create_notification({
                            name = "Error",
                            info = "Config file not found!",
                            lifetime = 3
                        })
                    end
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please select a config to load!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Save Config Button
        section:button({
            name = "Save Config", 
            callback = function()
                if ConfigSelected ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigSelected .. ".cfg"
                    writefile(configPath, library:get_config())
                    library.notifications:create_notification({
                        name = "Config Saved",
                        info = "Config '" .. ConfigSelected .. "' saved successfully!",
                        lifetime = 3
                    })
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please select a config to save!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Delete Config Button
        section:button({
            name = "Delete Config", 
            callback = function()
                if ConfigSelected ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigSelected .. ".cfg"
                    if isfile(configPath) then
                        delfile(configPath)
                        
                        -- Обновляем dropdown
                        local configFiles = {}
                        for idx, file in listfiles(library.directory .. "/configs") do
                            local name = file:gsub(library.directory .. "/configs\\", ""):gsub(".cfg", ""):gsub(library.directory .. "\\configs\\", "")
                            insert(configFiles, name)
                        end
                        
                        if #configFiles > 0 then
                            configList.refresh_options(configFiles)
                        else
                            configList.refresh_options({"No configs found"})
                        end
                        
                        library.notifications:create_notification({
                            name = "Config Deleted",
                            info = "Config '" .. ConfigSelected .. "' deleted successfully!",
                            lifetime = 3
                        })
                        ConfigSelected = ""
                    else
                        library.notifications:create_notification({
                            name = "Error",
                            info = "Config file not found!",
                            lifetime = 3
                        })
                    end
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please select a config to delete!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Auto refresh function
        local function refreshConfigList(showNotification)
            local configFiles = {}
            for idx, file in listfiles(library.directory .. "/configs") do
                local name = file:gsub(library.directory .. "/configs\\", ""):gsub(".cfg", ""):gsub(library.directory .. "\\configs\\", "")
                insert(configFiles, name)
            end
            
            if #configFiles > 0 then
                configList.refresh_options(configFiles)
            else
                configList.refresh_options({"No configs found"})
            end
            
            if showNotification then
                library.notifications:create_notification({
                    name = "Configs Refreshed",
                    info = "Config list updated!",
                    lifetime = 2
                })
            end
        end
        
        -- Auto refresh on startup
        refreshConfigList(false)
        
        -- Refresh Configs Button
        section:button({
            name = "Refresh Configs", 
            callback = function()
                refreshConfigList(true)
            end
        })
    end
end


library:update_theme("accent", rgb(0, 169, 255))
