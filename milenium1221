-- // Variables
local uis = game:GetService("UserInputService")
local players = game:GetService("Players")
local ws = game:GetService("Workspace")
local rs = game:GetService("ReplicatedStorage")
local http_service = game:GetService("HttpService")
local gui_service = game:GetService("GuiService")
local lighting = game:GetService("Lighting")
local run = game:GetService("RunService")
local stats = game:GetService("Stats")
local coregui = game:GetService("CoreGui")
local debris = game:GetService("Debris")
local tween_service = game:GetService("TweenService")
local sound_service = game:GetService("SoundService")

local vec2 = Vector2.new
local vec3 = Vector3.new
local dim2 = UDim2.new
local dim = UDim.new 
local rect = Rect.new
local cfr = CFrame.new
local empty_cfr = cfr()
local point_object_space = empty_cfr.PointToObjectSpace
local angle = CFrame.Angles
local dim_offset = UDim2.fromOffset

local color = Color3.new
local rgb = Color3.fromRGB
local hex = Color3.fromHex
local hsv = Color3.fromHSV
local rgbseq = ColorSequence.new
local rgbkey = ColorSequenceKeypoint.new
local numseq = NumberSequence.new
local numkey = NumberSequenceKeypoint.new

local camera = ws.CurrentCamera
local lp = players.LocalPlayer 
local mouse = lp:GetMouse() 
local gui_offset = gui_service:GetGuiInset().Y

local max = math.max 
local floor = math.floor 
local min = math.min 
local abs = math.abs 
local noise = math.noise
local rad = math.rad 
local random = math.random 
local pow = math.pow 
local sin = math.sin 
local pi = math.pi 
local tan = math.tan 
local atan2 = math.atan2 
local clamp = math.clamp 

local insert = table.insert 
local find = table.find 
local remove = table.remove
local concat = table.concat

-- // Silent Aimbot Variables
local drawing_new = Drawing.new
local hookmetamethod = hookmetamethod
local newcclosure = newcclosure
local getnamecallmethod = getnamecallmethod
local checkcaller = checkcaller
local game = game
local enum = Enum
local instance_new = Instance.new
local udim2_new = UDim2.new
local udim2_offset = UDim2.fromOffset

-- // Library
local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/OnChangedCallback/Library/refs/heads/main/v5"))()

-- // Utility Functions
do
    local utility = {}
    
    function utility:predict(targetPart, predictionX, predictionY)
        if not targetPart then return nil end
        local velocity = targetPart.Velocity or vec3(0, 0, 0)
        return targetPart.Position + vec3(
            velocity.X * predictionX,
            velocity.Y * predictionY,
            velocity.Z * predictionX
        )
    end
    
    function utility:isPlayerKO(player)
        if not player or not player.Character then return false end
        
        -- Проверяем K.O статус через BodyEffects
        local success, isKO = pcall(function()
            local playerInWorkspace = workspace.Players:FindFirstChild(player.Name)
            if playerInWorkspace and playerInWorkspace:FindFirstChild("BodyEffects") then
                local koEffect = playerInWorkspace.BodyEffects:FindFirstChild("K.O")
                if koEffect and koEffect:FindFirstChild("Value") then
                    return koEffect.Value.Value == true
                end
            end
            return false
        end)
        
        if success then
            return isKO
        end
        
        -- Fallback к проверке здоровья если BodyEffects недоступны
        local humanoid = player.Character:FindFirstChild("Humanoid")
        return humanoid and humanoid.Health <= 0
    end
    
    function utility:isPlayerGrabbed(player)
        if not player or not player.Character then return false end
        -- Проверяем, схвачен ли игрок
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid then
            return humanoid.PlatformStand or false
        end
        return false
    end
    
    function utility:hasForceField(player)
        if not player or not player.Character then return false end
        return player.Character:FindFirstChildOfClass("ForceField") ~= nil
    end
    
    function utility:getClosestPlayer(fovRadius, targetPart, useFov, checks, predX, predY)
        local closestPlayer, closestDistance = nil, math.huge
        
        for _, player in ipairs(players:GetPlayers()) do
            if player ~= lp and player.Character and player.Character:FindFirstChild(targetPart) then
                -- Проверки цели (только при выборе новой цели)
                local skipPlayer = false
                if checks then
                    if checks.checkKO and utility:isPlayerKO(player) then
                        skipPlayer = true
                    elseif checks.checkGrabbed and utility:isPlayerGrabbed(player) then
                        skipPlayer = true
                    elseif checks.checkForceField and utility:hasForceField(player) then
                        skipPlayer = true
                    end
                end
                
                if not skipPlayer then
                    local part = player.Character[targetPart]
                    local predictedPosition = utility:predict(part, predX or 0.021111111, predY or 0.0102)
                    if predictedPosition then
                        local screenPos, onScreen = camera:WorldToViewportPoint(predictedPosition)
                        if onScreen then
                            local mousePos = uis:GetMouseLocation()
                            local distance = (vec2(screenPos.X, screenPos.Y) - mousePos).Magnitude
                            
                            if useFov then
                                if distance < fovRadius and distance < closestDistance then
                                    closestPlayer = part
                                    closestDistance = distance
                                end
                            else
                                if distance < closestDistance then
                                    closestPlayer = part
                                    closestDistance = distance
                                end
                            end
                        end
                    end
                end
            end
        end
        return closestPlayer
    end
    
    _G.silentUtility = utility
end

-- // Window
local window = library:window({
    name = "R4ZE", 
    suffix = ".PUB", 
    gameInfo = "Raze.pub v3"
})

-- // Combat Tab
do
    local CameraBotTab, SilentBotTab = window:tab({
        name = "Combat", 
        icon = "rbxassetid://10734975692",  -- lucide-target
        tabs = {"CameraBot", "SilentBot"}
    })
    
    -- CameraBot Section
    do
        local CameraBotSection = CameraBotTab:column({})
        local section = CameraBotSection:section({name = "CameraBot", default = false})
        
        -- Placeholder for CameraBot features
        section:label({text = "CameraBot features will be added here"})
    end
    
    -- SilentBot Section  
    do
        local SilentBotSection = SilentBotTab:column({})
        local section = SilentBotSection:section({name = "SilentBot", default = false})
        
        -- Silent Aimbot Implementation
        do
            -- Silent Aimbot Variables
            local silentSettings = {
                enabled = false,
                stickyTarget = nil,
                fovRadius = 350,
                targetPart = "Head",
                useFov = true,
                showFov = true,
                fovColor = rgb(0, 169, 255),
                fovTransparency = 0.5,
                predictionX = 0.021111111,
                predictionY = 0.0102,
                stickyKey = enum.KeyCode.C,
                -- Visualise settings
                visualiseEnabled = false,
                highlightEnabled = false,
                highlightFillColor = rgb(0, 169, 255),
                highlightFillTransparency = 0.5,
                highlightOutlineColor = rgb(0, 169, 255),
                highlightOutlineTransparency = 0.5,
                tracerEnabled = false,
                tracerColor = rgb(0, 169, 255),
                tracerTransparency = 0.5,
                -- Checks settings
                checksEnabled = false,
                checkKO = false,
                checkGrabbed = false,
                checkForceField = false,
                -- Prediction settings
                predictionEnabled = false,
                customPredictionX = 0.021111111,
                customPredictionY = 0.0102,
                -- Resolver settings
                resolverEnabled = false,
                resolverMode = "Velocity"
            }
            
            -- ScreenGui FOV Circle
            local screenGui = instance_new("ScreenGui")
            screenGui.Name = "SilentAimbotFOV"
            screenGui.Parent = coregui
            
            local fovFrame = instance_new("Frame")
            fovFrame.Name = "FOVCircle"
            fovFrame.BackgroundTransparency = 1
            fovFrame.BorderSizePixel = 0
            fovFrame.Size = udim2_offset(silentSettings.fovRadius * 2, silentSettings.fovRadius * 2)
            fovFrame.Position = udim2_offset(0, 0)
            fovFrame.AnchorPoint = vec2(0.5, 0.5)
            fovFrame.Visible = false
            fovFrame.Parent = screenGui
            
            local fovCircle = instance_new("UIStroke")
            fovCircle.Thickness = 2
            fovCircle.Color = silentSettings.fovColor
            fovCircle.Transparency = silentSettings.fovTransparency
            fovCircle.Parent = fovFrame
            
            local fovCorner = instance_new("UICorner")
            fovCorner.CornerRadius = dim(0.5, 0)
            fovCorner.Parent = fovFrame
            
            local esp = nil
            local tracerLine = drawing_new("Line")
            tracerLine.Thickness = 2
            tracerLine.Color = silentSettings.tracerColor
            tracerLine.Transparency = silentSettings.tracerTransparency
            tracerLine.Visible = false
            
            -- Helper Functions
            local function highlightPlayer(target)
                if not silentSettings.visualiseEnabled or not silentSettings.highlightEnabled then
                    return
                end
                
                if esp then esp:Destroy() end
                esp = instance_new("Highlight")
                esp.Adornee = target.Parent
                esp.FillColor = silentSettings.highlightFillColor
                esp.OutlineColor = silentSettings.highlightOutlineColor
                esp.FillTransparency = silentSettings.highlightFillTransparency
                esp.OutlineTransparency = silentSettings.highlightOutlineTransparency
                esp.Parent = target.Parent
            end
            
            local function updateTracer(targetPosition)
                if not silentSettings.visualiseEnabled or not silentSettings.tracerEnabled then
                    tracerLine.Visible = false
                    return
                end
                
                if targetPosition then
                    tracerLine.Visible = true
                    tracerLine.From = uis:GetMouseLocation()
                    local screenPos, onScreen = camera:WorldToViewportPoint(targetPosition)
                    if onScreen then
                        tracerLine.To = vec2(screenPos.X, screenPos.Y)
                    else
                        tracerLine.Visible = false
                    end
                else
                    tracerLine.Visible = false
                end
            end
            
            local function destroyVisuals()
                if esp then esp:Destroy() end
                esp = nil
                tracerLine.Visible = false
            end
            
            local function getTarget()
                if silentSettings.stickyTarget then
                    if silentSettings.stickyTarget.Parent then
                        return silentSettings.stickyTarget
                    else
                        silentSettings.stickyTarget = nil
                    end
                end
                local checks = silentSettings.checksEnabled and {
                    checkKO = silentSettings.checkKO,
                    checkGrabbed = silentSettings.checkGrabbed,
                    checkForceField = silentSettings.checkForceField
                } or nil
                local predX = silentSettings.predictionEnabled and silentSettings.customPredictionX or silentSettings.predictionX
                local predY = silentSettings.predictionEnabled and silentSettings.customPredictionY or silentSettings.predictionY
                return _G.silentUtility:getClosestPlayer(silentSettings.fovRadius, silentSettings.targetPart, silentSettings.useFov, checks, predX, predY)
            end
            
            -- Main Silent Aimbot Toggle
            local mainToggle = section:toggle({
                name = "Silent Aimbot", 
                flag = "silent_enabled",
                type = "toggle",
                callback = function(bool)
                    silentSettings.enabled = bool
                    if not bool then
                        destroyVisuals()
                        fovFrame.Visible = false
                    end
                end,
                seperator = true
            })
            
            -- Sticky Target Keybind  
            section:keybind({
                name = "Sticky Target",
                flag = "silent_sticky_key", 
                key = enum.KeyCode.C,
                mode = "Toggle",
                default = false,
                callback = function(active)
                    if active then
                        -- Включен - схватить ближайшую цель
                        local checks = silentSettings.checksEnabled and {
                            checkKO = silentSettings.checkKO,
                            checkGrabbed = silentSettings.checkGrabbed,
                            checkForceField = silentSettings.checkForceField
                        } or nil
                        local predX = silentSettings.predictionEnabled and silentSettings.customPredictionX or silentSettings.predictionX
                        local predY = silentSettings.predictionEnabled and silentSettings.customPredictionY or silentSettings.predictionY
                        silentSettings.stickyTarget = _G.silentUtility:getClosestPlayer(silentSettings.fovRadius, silentSettings.targetPart, silentSettings.useFov, checks, predX, predY)
                    else
                        -- Выключен - отпустить цель
                        silentSettings.stickyTarget = nil
                    end
                end,
                seperator = true
            })
            
            -- FOV Toggle
            local fovToggle = section:toggle({
                name = "FOV", 
                flag = "silent_fov_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.useFov = bool
                end,
                seperator = true
            })
            
            -- FOV Settings Sub-section
            local fovSubSection = fovToggle:settings({})
            
            fovSubSection:slider({
                name = "FOV Size", 
                flag = "silent_fov_size",
                min = 50, 
                max = 500, 
                default = 350, 
                interval = 1,
                callback = function(value)
                    silentSettings.fovRadius = value
                    fovFrame.Size = udim2_offset(value * 2, value * 2)
                end,
                seperator = true
            })
            
            local showFovToggle = fovSubSection:toggle({
                name = "Show FOV", 
                flag = "silent_show_fov",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.showFov = bool
                    if not bool then
                        fovFrame.Visible = false
                    end
                end,
                seperator = true
            })
            
            showFovToggle:colorpicker({
                name = "FOV Color",
                flag = "silent_fov_color",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.fovColor = color
                    silentSettings.fovTransparency = transparency
                    fovCircle.Color = color
                    fovCircle.Transparency = transparency
                end
            })
            
            -- Visualise Toggle
            local visualiseToggle = section:toggle({
                name = "Visualise", 
                flag = "silent_visualise_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.visualiseEnabled = bool
                    if not bool then
                        destroyVisuals()
                    end
                end,
                seperator = true
            })
            
            -- Visualise Settings Sub-section
            local visualiseSubSection = visualiseToggle:settings({})
            
            -- Highlight Toggle
            local highlightToggle = visualiseSubSection:toggle({
                name = "Highlight", 
                flag = "silent_highlight_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.highlightEnabled = bool
                    if not bool and esp then
                        esp:Destroy()
                        esp = nil
                    end
                end,
                seperator = true
            })
            
            highlightToggle:colorpicker({
                name = "Fill Color",
                flag = "silent_highlight_fill",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.highlightFillColor = color
                    silentSettings.highlightFillTransparency = transparency
                    if esp then
                        esp.FillColor = color
                        esp.FillTransparency = transparency
                    end
                end
            })
            
            highlightToggle:colorpicker({
                name = "Outline Color",
                flag = "silent_highlight_outline",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.highlightOutlineColor = color
                    silentSettings.highlightOutlineTransparency = transparency
                    if esp then
                        esp.OutlineColor = color
                        esp.OutlineTransparency = transparency
                    end
                end
            })
            
            -- Tracer Toggle
            local tracerToggle = visualiseSubSection:toggle({
                name = "Tracer", 
                flag = "silent_tracer_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.tracerEnabled = bool
                    if not bool then
                        tracerLine.Visible = false
                    end
                end,
                seperator = true
            })
            
            tracerToggle:colorpicker({
                name = "Tracer Color",
                flag = "silent_tracer_color",
                color = rgb(0, 169, 255),
                alpha = 0.5,
                callback = function(color, transparency)
                    silentSettings.tracerColor = color
                    -- Для Drawing API: больше fade = меньше прозрачности (инвертируем)
                    silentSettings.tracerTransparency = 1 - transparency
                    tracerLine.Color = color
                    tracerLine.Transparency = 1 - transparency
                end
            })
            
            -- Aimpart Dropdown
            section:dropdown({
                name = "Aimpart",
                flag = "silent_aimpart",
                items = {
                    "Head",
                    "UpperTorso", 
                    "LowerTorso",
                    "LeftUpperArm",
                    "LeftLowerArm",
                    "LeftHand",
                    "RightUpperArm",
                    "RightLowerArm", 
                    "RightHand",
                    "LeftUpperLeg",
                    "LeftLowerLeg",
                    "LeftFoot",
                    "RightUpperLeg",
                    "RightLowerLeg",
                    "RightFoot"
                },
                default = "Head",
                callback = function(selected)
                    silentSettings.targetPart = selected
                end,
                seperator = true
            })
            
            
            -- Checks Toggle
            local checksToggle = section:toggle({
                name = "Checks", 
                flag = "silent_checks_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checksEnabled = bool
                end,
                seperator = true
            })
            
            -- Checks Settings Sub-section
            local checksSubSection = checksToggle:settings({})
            
            -- KO Check
            checksSubSection:toggle({
                name = "Check K.O",
                flag = "silent_check_ko",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkKO = bool
                end,
                seperator = true
            })
            
            -- Grabbed Check
            checksSubSection:toggle({
                name = "Check Grabbed",
                flag = "silent_check_grabbed",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkGrabbed = bool
                end,
                seperator = true
            })
            
            -- ForceField Check
            checksSubSection:toggle({
                name = "Check ForceField",
                flag = "silent_check_forcefield",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.checkForceField = bool
                end,
                seperator = true
            })
            
            -- Prediction Toggle
            local predictionToggle = section:toggle({
                name = "Prediction", 
                flag = "silent_prediction_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.predictionEnabled = bool
                end,
                seperator = true
            })
            
            -- Prediction Settings Sub-section
            local predictionSubSection = predictionToggle:settings({})
            
            -- Prediction X Textbox
            predictionSubSection:textbox({
                name = "Prediction X",
                flag = "silent_prediction_x",
                placeholder = "0.021111111",
                callback = function(text)
                    local value = tonumber(text)
                    if value then
                        silentSettings.customPredictionX = value
                    end
                end,
                seperator = true
            })
            
            -- Prediction Y Textbox
            predictionSubSection:textbox({
                name = "Prediction Y",
                flag = "silent_prediction_y",
                placeholder = "0.0102",
                callback = function(text)
                    local value = tonumber(text)
                    if value then
                        silentSettings.customPredictionY = value
                    end
                end,
                seperator = true
            })
            
            -- Resolver Toggle
            local resolverToggle = section:toggle({
                name = "Resolver", 
                flag = "silent_resolver_enabled",
                type = "checkbox",
                callback = function(bool)
                    silentSettings.resolverEnabled = bool
                end,
                seperator = true
            })
            
            -- Resolver Settings Sub-section
            local resolverSubSection = resolverToggle:settings({})
            
            -- Resolver Mode Dropdown
            resolverSubSection:dropdown({
                name = "Resolver Mode",
                flag = "silent_resolver_mode",
                items = {
                    "Velocity",
                    "MoveDirection", 
                    "CalculateCFrame"
                },
                default = "Velocity",
                callback = function(selected)
                    silentSettings.resolverMode = selected
                end,
                seperator = true
            })
            
            -- Main Loop
            run.RenderStepped:Connect(function()
                if fovFrame and silentSettings.showFov and silentSettings.useFov then
                    local mousePos = uis:GetMouseLocation()
                    fovFrame.Position = udim2_offset(mousePos.X, mousePos.Y - gui_offset)
                    fovFrame.Visible = true
                else
                    fovFrame.Visible = false
                end
                
                if not silentSettings.enabled then
                    destroyVisuals()
                    return
                end
                
                local target = getTarget()
                if target then
                    local predictedPosition = _G.silentUtility:predict(target, silentSettings.predictionX, silentSettings.predictionY)
                    if predictedPosition then
                        highlightPlayer(target)
                        updateTracer(predictedPosition)
                    else
                        destroyVisuals()
                    end
                else
                    destroyVisuals()
                end
            end)
            
            -- AIMBOT HOOK
            local __aimbot
            __aimbot = hookmetamethod(game, "__index", newcclosure(function(t, k)
                if t:IsA("Mouse") and (k == "Hit" or k == "Target") then
                    if not (silentSettings.enabled and getTarget()) then
                        return __aimbot(t, k)
                    end
                    
                    local target = getTarget()
                    if target then
                        local predictedPosition = _G.silentUtility:predict(target, silentSettings.predictionX, silentSettings.predictionY)
                        if predictedPosition then
                            local hit = cfr(predictedPosition)
                            return k == "Hit" and hit or target
                        end
                    end
                end
                return __aimbot(t, k)
            end))
            
        end
    end
end

-- // Visuals Tab  
do
    local VisualsTab = window:tab({
        name = "Visuals", 
        icon = "rbxassetid://10723346959"  -- lucide-eye
    })
    
    -- Visuals Section
    do
        local VisualsSection = VisualsTab:column({})
        local section = VisualsSection:section({name = "Visuals", default = false})
        
        -- Placeholder for visual features
        section:label({text = "Visual features will be added here"})
    end
end

-- // Misc Tab
do
    local MiscTab = window:tab({
        name = "Misc", 
        icon = "rbxassetid://10734934585"  -- lucide-rocket
    })
    
    -- Misc Section
    do
        local MiscSection = MiscTab:column({})
        local section = MiscSection:section({name = "Misc", default = false})
        
        -- Placeholder for misc features
        section:label({text = "Miscellaneous features will be added here"})
    end
end

-- // Settings Tab
do
    
    local SettingsTab, ConfigsTab = window:tab({
        name = "Settings", 
        icon = "rbxassetid://10734950309",  -- lucide-settings
        tabs = {"Main", "Configs"}
    })
    
    -- Settings Section
    do
        local SettingsSection = SettingsTab:column({})
        local section = SettingsSection:section({name = "Settings", default = false})
        
        -- Set default accent color
        library:update_theme("accent", rgb(0, 169, 255))
        
        -- Menu Keybind
        section:keybind({
            name = "Menu Keybind", 
            key = Enum.KeyCode.RightControl,
            mode = "Toggle",
            default = false,
            callback = function(bool) 
                window.toggle_menu(bool) 
            end,
            info = "Клавиша для открытия/закрытия меню"
        })
        
        -- Game Interaction Buttons
        section:button({
            name = "Copy JobId",
            callback = function()
                setclipboard(game.JobId)
                library.notifications:create_notification({
                    name = "JobId Copied",
                    info = "JobId copied to clipboard!",
                    lifetime = 3
                })
            end,
            info = "Copy current server JobId to clipboard"
        })
        
        section:button({
            name = "Copy GameID",
            callback = function()
                setclipboard(game.GameId)
                library.notifications:create_notification({
                    name = "GameID Copied",
                    info = "GameID copied to clipboard!",
                    lifetime = 3
                })
            end,
            info = "Copy current game ID to clipboard"
        })
        
        section:button({
            name = "Copy Join Script",
            callback = function()
                setclipboard(
                    'game:GetService("TeleportService"):TeleportToPlaceInstance(' ..
                        game.PlaceId .. ', "' .. game.JobId .. '", game.Players.LocalPlayer)'
                )
                library.notifications:create_notification({
                    name = "Join Script Copied",
                    info = "Join script copied to clipboard!",
                    lifetime = 3
                })
            end,
            info = "Copy teleport script to join this server"
        })
        
        section:button({
            name = "Rejoin",
            callback = function()
                game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, lp)
            end,
            info = "Rejoin current server"
        })
        
        section:button({
            name = "Join New Server",
            callback = function()
                local serverData = 
                    http_service:JSONDecode(
                    game:HttpGetAsync(
                        "https://games.roblox.com/v1/games/" ..
                            game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
                    )
                )
                local validServers = {}
                for _, server in pairs(serverData.data) do
                    if server.playing >= library.flags["min_players"] and server.playing <= library.flags["max_players"] then
                        insert(validServers, server)
                    end
                end
                
                if #validServers > 0 then
                    local randomServer = validServers[random(1, #validServers)]
                    game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, randomServer.id)
                else
                    library.notifications:create_notification({
                        name = "No Servers Found",
                        info = "No servers found matching player count criteria!",
                        lifetime = 3
                    })
                end
            end,
            info = "Join a random server within player count range"
        })
        
        section:slider({
            name = "Min Players", 
            flag = "min_players", 
            min = 0, 
            max = 40, 
            default = 1, 
            interval = 1,
            info = "Minimum number of players required on server"
        })
        
        section:slider({
            name = "Max Players", 
            flag = "max_players", 
            min = 0, 
            max = 40, 
            default = 15, 
            interval = 1,
            info = "Maximum number of players allowed on server"
        })
        
        -- Notification Test Button
        section:button({
            name = "Notification Test", 
            callback = function()
                library.notifications:create_notification({
                    name = "Test Notification",
                    info = "This is a test notification with random colors!",
                    lifetime = 5
                })
            end
        })
    end
    
    -- Configs Section
    do
        local ConfigsSection = ConfigsTab:column({})
        local section = ConfigsSection:section({name = "Configs", default = true})
        
        local ConfigName = ""
        local ConfigSelected = ""
        
        -- Config List
        local configList = section:dropdown({
            name = "Configs",
            items = {"Default Config"},
            callback = function(selected)
                ConfigSelected = selected
                print("Config Selected:", selected)
            end,
            flag = "config_list"
        })
        
        -- Config Name Input
        section:textbox({
            name = "Config Name", 
            placeholder = "Enter config name...",
            callback = function(text)
                ConfigName = text
            end,
            flag = "config_name_input"
        })
        
        -- Create Config Button
        section:button({
            name = "Create Config", 
            callback = function()
                if ConfigName ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigName .. ".cfg"
                    if not isfile(configPath) then
                        writefile(configPath, library:get_config())
                        
                        -- Обновляем dropdown
                        local configFiles = {}
                        for idx, file in listfiles(library.directory .. "/configs") do
                            local name = file:gsub(library.directory .. "/configs\\", ""):gsub(".cfg", ""):gsub(library.directory .. "\\configs\\", "")
                            insert(configFiles, name)
                        end
                        configList.refresh_options(configFiles)
                        
                        library.notifications:create_notification({
                            name = "Config Created",
                            info = "Config '" .. ConfigName .. "' created successfully!",
                            lifetime = 3
                        })
                    else
                        library.notifications:create_notification({
                            name = "Error",
                            info = "Config '" .. ConfigName .. "' already exists!",
                            lifetime = 3
                        })
                    end
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please enter a config name!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Load Config Button
        section:button({
            name = "Load Config", 
            callback = function()
                if ConfigSelected ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigSelected .. ".cfg"
                    if isfile(configPath) then
                        library:load_config(readfile(configPath))
                        library.notifications:create_notification({
                            name = "Config Loaded",
                            info = "Config '" .. ConfigSelected .. "' loaded successfully!",
                            lifetime = 3
                        })
                    else
                        library.notifications:create_notification({
                            name = "Error",
                            info = "Config file not found!",
                            lifetime = 3
                        })
                    end
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please select a config to load!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Save Config Button
        section:button({
            name = "Save Config", 
            callback = function()
                if ConfigSelected ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigSelected .. ".cfg"
                    writefile(configPath, library:get_config())
                    library.notifications:create_notification({
                        name = "Config Saved",
                        info = "Config '" .. ConfigSelected .. "' saved successfully!",
                        lifetime = 3
                    })
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please select a config to save!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Delete Config Button
        section:button({
            name = "Delete Config", 
            callback = function()
                if ConfigSelected ~= "" then
                    local configPath = library.directory .. "/configs/" .. ConfigSelected .. ".cfg"
                    if isfile(configPath) then
                        delfile(configPath)
                        
                        -- Обновляем dropdown
                        local configFiles = {}
                        for idx, file in listfiles(library.directory .. "/configs") do
                            local name = file:gsub(library.directory .. "/configs\\", ""):gsub(".cfg", ""):gsub(library.directory .. "\\configs\\", "")
                            insert(configFiles, name)
                        end
                        
                        if #configFiles > 0 then
                            configList.refresh_options(configFiles)
                        else
                            configList.refresh_options({"No configs found"})
                        end
                        
                        library.notifications:create_notification({
                            name = "Config Deleted",
                            info = "Config '" .. ConfigSelected .. "' deleted successfully!",
                            lifetime = 3
                        })
                        ConfigSelected = ""
                    else
                        library.notifications:create_notification({
                            name = "Error",
                            info = "Config file not found!",
                            lifetime = 3
                        })
                    end
                else
                    library.notifications:create_notification({
                        name = "Error",
                        info = "Please select a config to delete!",
                        lifetime = 3
                    })
                end
            end
        })
        
        -- Auto refresh function
        local function refreshConfigList(showNotification)
            local configFiles = {}
            for idx, file in listfiles(library.directory .. "/configs") do
                local name = file:gsub(library.directory .. "/configs\\", ""):gsub(".cfg", ""):gsub(library.directory .. "\\configs\\", "")
                insert(configFiles, name)
            end
            
            if #configFiles > 0 then
                configList.refresh_options(configFiles)
            else
                configList.refresh_options({"No configs found"})
            end
            
            if showNotification then
                library.notifications:create_notification({
                    name = "Configs Refreshed",
                    info = "Config list updated!",
                    lifetime = 2
                })
            end
        end
        
        -- Auto refresh on startup
        refreshConfigList(false)
        
        -- Refresh Configs Button
        section:button({
            name = "Refresh Configs", 
            callback = function()
                refreshConfigList(true)
            end
        })
    end
end


library:update_theme("accent", rgb(0, 169, 255))
